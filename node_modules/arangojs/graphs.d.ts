/**
 * ```ts
 * import type {
 *   Graph,
 *   GraphVertexCollection,
 *   GraphEdgeCollection,
 * } from "arangojs/graphs";
 * ```
 *
 * The "graphs" module provides graph related types and interfaces
 * for TypeScript.
 *
 * @packageDocumentation
 */
import * as collections from "./collections.js";
import * as databases from "./databases.js";
import * as documents from "./documents.js";
/**
 * Options for retrieving a document from a graph collection.
 */
export type ReadGraphDocumentOptions = {
    /**
     * If set to a document revision, the document will only be returned if its
     * `_rev` property matches this value.
     *
     * See also {@link documents.DocumentMetadata}.
     */
    rev?: string;
    /**
     * If set to `true`, `null` is returned instead of an exception being thrown
     * if the document does not exist.
     *
     * Default: `false`
     */
    graceful?: boolean;
    /**
     * If set to `true`, the request will explicitly permit ArangoDB to return a
     * potentially dirty or stale result and arangojs will load balance the
     * request without distinguishing between leaders and followers.
     *
     * Default: `false`
     */
    allowDirtyRead?: boolean;
};
/**
 * Options for inserting a document into a graph collection.
 */
export type InsertGraphDocumentOptions = {
    /**
     * If set to `true`, data will be synchronized to disk before returning.
     *
     * Default: `false`
     */
    waitForSync?: boolean;
    /**
     * If set to `true`, the complete new document will be returned as the `new`
     * property on the result object.
     *
     * Default: `false`
     */
    returnNew?: boolean;
};
/**
 * Options for replacing a document in a graph collection.
 */
export type ReplaceGraphDocumentOptions = {
    /**
     * If set to a document revision, the document will only be modified if its
     * `_rev` property matches this value.
     *
     * See also {@link documents.DocumentMetadata}.
     */
    rev?: string;
    /**
     * If set to `true`, data will be synchronized to disk before returning.
     *
     * Default: `false`
     */
    waitForSync?: boolean;
    /**
     * If set to `false`, properties with a value of `null` will be removed from
     * the new document.
     *
     * Default: `true`
     */
    keepNull?: boolean;
    /**
     * If set to `true`, the complete old document will be returned as the `old`
     * property on the result object.
     *
     * Default: `false`
     */
    returnOld?: boolean;
    /**
     * If set to `true`, the complete new document will be returned as the `new`
     * property on the result object.
     *
     * Default: `false`
     */
    returnNew?: boolean;
};
/**
 * Options for removing a document from a graph collection.
 */
export type RemoveGraphDocumentOptions = {
    /**
     * If set to a document revision, the document will only be removed if its
     * `_rev` property matches this value.
     *
     * See also {@link documents.DocumentMetadata}.
     */
    rev?: string;
    /**
     * If set to `true`, data will be synchronized to disk before returning.
     *
     * Default: `false`
     */
    waitForSync?: boolean;
    /**
     * If set to `true`, the complete old document will be returned as the `old`
     * property on the result object.
     *
     * Default: `false`
     */
    returnOld?: boolean;
};
/**
 * An edge definition used to define a collection of edges in a {@link Graph}.
 */
export type EdgeDefinitionOptions = {
    /**
     * Collection containing the edges.
     */
    collection: string | collections.ArangoCollection;
    /**
     * Collection or collections containing the start vertices.
     */
    from: (string | collections.ArangoCollection)[] | string | collections.ArangoCollection;
    /**
     * Collection or collections containing the end vertices.
     */
    to: (string | collections.ArangoCollection)[] | string | collections.ArangoCollection;
};
/**
 * General information about a graph.
 */
export type GraphDescription = {
    /**
     * Key of the document internally representing this graph.
     *
     * See {@link documents.DocumentMetadata}.
     *
     * @internal
     */
    _key: string;
    /**
     * Unique identifier of the document internally representing this graph.
     *
     * See {@link documents.DocumentMetadata}.
     *
     * @internal
     */
    _id: string;
    /**
     * Revision of the document internally representing this graph.
     *
     * See {@link documents.DocumentMetadata}.
     *
     * @internal
     */
    _rev: string;
    /**
     * Name of the graph.
     */
    name: string;
    /**
     * Definitions for the relations of the graph.
     */
    edgeDefinitions: EdgeDefinition[];
    /**
     * Additional vertex collections. Documents within these collections do not
     * have edges within this graph.
     */
    orphanCollections: string[];
    /**
     * (Cluster only.) Number of shards that is used for every collection
     * within this graph.
     */
    numberOfShards?: number;
    /**
     * (Cluster only.) Replication factor used when initially creating
     * collections for this graph.
     */
    replicationFactor?: number;
    /**
     * (Cluster only.) Write concern for new collections in the graph.
     */
    writeConcern?: number;
    /**
     * (Enterprise Edition cluster only.) If set to `true`, the graph is a
     * SatelliteGraph.
     */
    isSatellite?: boolean;
    /**
     * (Enterprise Edition cluster only.) If set to `true`, the graph has been
     * created as a SmartGraph.
     */
    isSmart?: boolean;
    /**
     * (Enterprise Edition cluster only.) Attribute containing the shard key
     * value to use for smart sharding.
     */
    smartGraphAttribute?: string;
    /**
     * (Enterprise Edition cluster only.) If set to `true`, the graph has been
     * created as a Disjoint SmartGraph.
     */
    isDisjoint?: boolean;
};
/**
 * Definition of a relation in a {@link Graph}.
 */
export type EdgeDefinition = {
    /**
     * Name of the collection containing the edges.
     */
    collection: string;
    /**
     * Array of names of collections containing the start vertices.
     */
    from: string[];
    /**
     * Array of names of collections containing the end vertices.
     */
    to: string[];
};
/**
 * Option for creating a graph.
 */
export type CreateGraphOptions = {
    /**
     * If set to `true`, the request will wait until all modifications have been
     * synchronized to disk before returning successfully.
     *
     * Default: `false`
     */
    waitForSync?: boolean;
    /**
     * Additional vertex collections. Documents within these collections do not
     * have edges within this graph.
     */
    orphanCollections?: (string | collections.ArangoCollection)[] | string | collections.ArangoCollection;
    /**
     * (Cluster only.) Number of shards that is used for every collection
     * within this graph.
     *
     * Has no effect when `replicationFactor` is set to `"satellite"`.
     */
    numberOfShards?: number;
    /**
     * (Cluster only.) Replication factor used when initially creating
     * collections for this graph.
     *
     * Default: `1`
     */
    replicationFactor?: number | "satellite";
    /**
     * (Cluster only.) Write concern for new collections in the graph.
     *
     * Has no effect when `replicationFactor` is set to `"satellite"`.
     */
    writeConcern?: number;
    /**
     * (Enterprise Edition cluster only.) If set to `true`, the graph will be
     * created as a SmartGraph.
     *
     * Default: `false`
     */
    isSmart?: boolean;
    /**
     * (Enterprise Edition cluster only.) Attribute containing the shard key
     * value to use for smart sharding.
     */
    smartGraphAttribute?: string;
    /**
     * (Enterprise Edition cluster only.) If set to `true`, the graph will be
     * created as a Disjoint SmartGraph.
     *
     * Default: `false`
     */
    isDisjoint?: boolean;
    /**
     * (Enterprise Edition cluster only.) Collections to be included in a Hybrid
     * SmartGraph.
     */
    satellites?: (string | collections.ArangoCollection)[];
};
/**
 * Options for adding a vertex collection to a graph.
 */
export type AddVertexCollectionOptions = {
    /**
     * (Enterprise Edition cluster only.) Collections to be included in a Hybrid
     * SmartGraph.
     */
    satellites?: (string | collections.ArangoCollection)[];
};
/**
 * Options for adding an edge definition to a graph.
 */
export type AddEdgeDefinitionOptions = {
    /**
     * (Enterprise Edition cluster only.) Collections to be included in a Hybrid
     * SmartGraph.
     */
    satellites?: (string | collections.ArangoCollection)[];
};
/**
 * Options for replacing an edge definition in a graph.
 */
export type ReplaceEdgeDefinitionOptions = {
    /**
     * (Enterprise Edition cluster only.) Collections to be included in a Hybrid
     * SmartGraph.
     */
    satellites?: string[];
};
/**
 * Represents a {@link collections.DocumentCollection} of vertices in a {@link Graph}.
 *
 * @param EntryResultType - Type to represent vertex document contents returned
 * by the server (including computed properties).
 * @param EntryInputType - Type to represent vertex document contents passed
 * when inserting or replacing vertex documents (without computed properties).
 */
export declare class GraphVertexCollection<EntryResultType extends Record<string, any> = any, EntryInputType extends Record<string, any> = EntryResultType> implements collections.ArangoCollection {
    protected _db: databases.Database;
    protected _name: string;
    protected _graph: Graph;
    protected _collection: collections.DocumentCollection<EntryResultType, EntryInputType>;
    /**
     * @internal
     */
    constructor(db: databases.Database, name: string, graph: Graph);
    /**
     * @internal
     *
     * Indicates that this object represents an ArangoDB collection.
     */
    get isArangoCollection(): true;
    /**
     * Database this vertex collection belongs to.
     */
    get database(): databases.Database;
    /**
     * Name of the collection.
     */
    get name(): string;
    /**
     * A {@link collections.DocumentCollection} instance for this vertex collection.
     */
    get collection(): collections.DocumentCollection<EntryResultType, EntryInputType>;
    /**
     * The {@link Graph} instance this vertex collection is bound to.
     */
    get graph(): Graph;
    /**
     * Checks whether a vertex matching the given key or id exists in this
     * collection.
     *
     * Throws an exception when passed a vertex or `_id` from a different
     * collection.
     *
     * @param selector - Document `_key`, `_id` or object with either of those
     * properties (e.g. a vertex from this collection).
     *
     * @example
     * ```js
     * const graph = db.graph("some-graph");
     * const collection = graph.vertexCollection("vertices");
     * const exists = await collection.vertexExists("abc123");
     * if (!exists) {
     *   console.log("Vertex does not exist");
     * }
     * ```
     */
    vertexExists(selector: documents.DocumentSelector): Promise<boolean>;
    /**
     * Retrieves the vertex matching the given key or id.
     *
     * Throws an exception when passed a vertex or `_id` from a different
     * collection.
     *
     * @param selector - Document `_key`, `_id` or object with either of those
     * properties (e.g. a vertex from this collection).
     * @param options - Options for retrieving the vertex.
     *
     * @example
     * ```js
     * const graph = db.graph("some-graph");
     * const collection = graph.vertexCollection("vertices");
     * try {
     *   const vertex = await collection.vertex("abc123");
     *   console.log(vertex);
     * } catch (e: any) {
     *   console.error("Could not find vertex");
     * }
     * ```
     *
     * @example
     * ```js
     * const graph = db.graph("some-graph");
     * const collection = graph.vertexCollection("vertices");
     * const vertex = await collection.vertex("abc123", { graceful: true });
     * if (vertex) {
     *   console.log(vertex);
     * } else {
     *   console.error("Could not find vertex");
     * }
     * ```
     */
    vertex(selector: documents.DocumentSelector, options?: ReadGraphDocumentOptions): Promise<documents.Document<EntryResultType>>;
    /**
     * Retrieves the vertex matching the given key or id.
     *
     * Throws an exception when passed a vertex or `_id` from a different
     * collection.
     *
     * @param selector - Document `_key`, `_id` or object with either of those
     * properties (e.g. a vertex from this collection).
     * @param graceful - If set to `true`, `null` is returned instead of an
     * exception being thrown if the vertex does not exist.
     *
     * @example
     * ```js
     * const graph = db.graph("some-graph");
     * const collection = graph.vertexCollection("vertices");
     * try {
     *   const vertex = await collection.vertex("abc123", false);
     *   console.log(vertex);
     * } catch (e: any) {
     *   console.error("Could not find vertex");
     * }
     * ```
     *
     * @example
     * ```js
     * const graph = db.graph("some-graph");
     * const collection = graph.vertexCollection("vertices");
     * const vertex = await collection.vertex("abc123", true);
     * if (vertex) {
     *   console.log(vertex);
     * } else {
     *   console.error("Could not find vertex");
     * }
     * ```
     */
    vertex(selector: documents.DocumentSelector, graceful: boolean): Promise<documents.Document<EntryResultType>>;
    /**
     * Inserts a new vertex with the given `data` into the collection.
     *
     * @param data - The contents of the new vertex.
     * @param options - Options for inserting the vertex.
     *
     * @example
     * ```js
     * const graph = db.graph("some-graph");
     * const collection = graph.vertexCollection("friends");
     * const result = await collection.save(
     *   { _key: "a", color: "blue", count: 1 },
     *   { returnNew: true }
     * );
     * console.log(result.new.color, result.new.count); // "blue" 1
     * ```
     */
    save(data: documents.DocumentData<EntryInputType>, options?: InsertGraphDocumentOptions): Promise<documents.DocumentMetadata & {
        new?: documents.Document<EntryResultType>;
    }>;
    /**
     * Replaces an existing vertex in the collection.
     *
     * Throws an exception when passed a vertex or `_id` from a different
     * collection.
     *
     * @param selector - Document `_key`, `_id` or object with either of those
     * properties (e.g. a vertex from this collection).
     * @param newData - The contents of the new vertex.
     * @param options - Options for replacing the vertex.
     *
     * @example
     * ```js
     * const graph = db.graph("some-graph");
     * const collection = graph.collection("vertices");
     * await collection.save({ _key: "a", color: "blue", count: 1 });
     * const result = await collection.replace(
     *   "a",
     *   { color: "red" },
     *   { returnNew: true }
     * );
     * console.log(result.new.color, result.new.count); // "red" undefined
     * ```
     */
    replace(selector: documents.DocumentSelector, newData: documents.DocumentData<EntryInputType>, options?: ReplaceGraphDocumentOptions): Promise<documents.DocumentMetadata & {
        new?: documents.Document<EntryResultType>;
        old?: documents.Document<EntryResultType>;
    }>;
    /**
     * Updates an existing vertex in the collection.
     *
     * Throws an exception when passed a vertex or `_id` from a different
     * collection.
     *
     * @param selector - Document `_key`, `_id` or object with either of those
     * properties (e.g. a vertex from this collection).
     * @param newData - The data for updating the vertex.
     * @param options - Options for updating the vertex.
     *
     * @example
     * ```js
     * const graph = db.graph("some-graph");
     * const collection = graph.collection("vertices");
     * await collection.save({ _key: "a", color: "blue", count: 1 });
     * const result = await collection.update(
     *   "a",
     *   { count: 2 },
     *   { returnNew: true }
     * );
     * console.log(result.new.color, result.new.count); // "blue" 2
     * ```
     */
    update(selector: documents.DocumentSelector, newData: documents.Patch<documents.DocumentData<EntryInputType>>, options?: ReplaceGraphDocumentOptions): Promise<documents.DocumentMetadata & {
        new?: documents.Document<EntryResultType>;
        old?: documents.Document<EntryResultType>;
    }>;
    /**
     * Removes an existing vertex from the collection.
     *
     * Throws an exception when passed a vertex or `_id` from a different
     * collection.
     *
     * @param selector - Document `_key`, `_id` or object with either of those
     * properties (e.g. a vertex from this collection).
     * @param options - Options for removing the vertex.
     *
     * @example
     * ```js
     * const graph = db.graph("some-graph");
     * const collection = graph.vertexCollection("vertices");
     * await collection.remove("abc123");
     * // document with key "abc123" deleted
     * ```
     *
     * @example
     * ```js
     * const graph = db.graph("some-graph");
     * const collection = graph.vertexCollection("vertices");
     * const doc = await collection.vertex("abc123");
     * await collection.remove(doc);
     * // document with key "abc123" deleted
     * ```
     */
    remove(selector: documents.DocumentSelector, options?: RemoveGraphDocumentOptions): Promise<documents.DocumentMetadata & {
        old?: documents.Document<EntryResultType>;
    }>;
}
/**
 * Represents a {@link collections.EdgeCollection} of edges in a {@link Graph}.
 *
 * @param EntryResultType - Type to represent edge document contents returned
 * by the server (including computed properties).
 * @param EntryInputType - Type to represent edge document contents passed
 * when inserting or replacing edge documents (without computed properties).
 */
export declare class GraphEdgeCollection<EntryResultType extends Record<string, any> = any, EntryInputType extends Record<string, any> = EntryResultType> implements collections.ArangoCollection {
    protected _db: databases.Database;
    protected _name: string;
    protected _graph: Graph;
    protected _collection: collections.EdgeCollection<EntryResultType, EntryInputType>;
    /**
     * @internal
     */
    constructor(db: databases.Database, name: string, graph: Graph);
    /**
     * @internal
     *
     * Indicates that this object represents an ArangoDB collection.
     */
    get isArangoCollection(): true;
    /**
     * Database this edge collection belongs to.
     */
    get database(): databases.Database;
    /**
     * Name of the collection.
     */
    get name(): string;
    /**
     * A {@link collections.EdgeCollection} instance for this edge collection.
     */
    get collection(): collections.EdgeCollection<EntryResultType, EntryInputType>;
    /**
     * The {@link Graph} instance this edge collection is bound to.
     */
    get graph(): Graph;
    /**
     * Checks whether a edge matching the given key or id exists in this
     * collection.
     *
     * Throws an exception when passed a edge or `_id` from a different
     * collection.
     *
     * @param selector - Document `_key`, `_id` or object with either of those
     * properties (e.g. a edge from this collection).
     *
     * @example
     * ```js
     * const graph = db.graph("some-graph");
     * const collection = graph.edgeCollection("friends")
     * const exists = await collection.edgeExists("abc123");
     * if (!exists) {
     *   console.log("Edge does not exist");
     * }
     * ```
     */
    edgeExists(selector: documents.DocumentSelector): Promise<boolean>;
    /**
     * Retrieves the edge matching the given key or id.
     *
     * Throws an exception when passed a edge or `_id` from a different
     * collection, or if the edge does not exist.
     *
     * @param selector - Document `_key`, `_id` or object with either of those
     * properties (e.g. a edge from this collection).
     * @param options - Options for retrieving the edge.
     *
     * @example
     * ```js
     * const graph = db.graph("some-graph");
     * const collection = graph.edgeCollection("friends")
     * try {
     *   const edge = await collection.edge("abc123");
     *   console.log(edge);
     * } catch (e: any) {
     *   console.error("Could not find edge");
     * }
     * ```
     *
     * @example
     * ```js
     * const graph = db.graph("some-graph");
     * const collection = graph.edgeCollection("friends")
     * const edge = await collection.edge("abc123", { graceful: true });
     * if (edge) {
     *   console.log(edge);
     * } else {
     *   console.error("Edge does not exist");
     * }
     * ```
     */
    edge(selector: documents.DocumentSelector, options?: ReadGraphDocumentOptions): Promise<documents.Edge<EntryResultType>>;
    /**
     * Retrieves the edge matching the given key or id.
     *
     * Throws an exception when passed a edge or `_id` from a different
     * collection, or if the edge does not exist.
     *
     * @param selector - Document `_key`, `_id` or object with either of those
     * properties (e.g. a edge from this collection).
     * @param graceful - If set to `true`, `null` is returned instead of an
     * exception being thrown if the edge does not exist.
     *
     * @example
     * ```js
     * const graph = db.graph("some-graph");
     * const collection = graph.edgeCollection("friends")
     * try {
     *   const edge = await collection.edge("abc123", false);
     *   console.log(edge);
     * } catch (e: any) {
     *   console.error("Could not find edge");
     * }
     * ```
     *
     * @example
     * ```js
     * const graph = db.graph("some-graph");
     * const collection = graph.edgeCollection("friends")
     * const edge = await collection.edge("abc123", true);
     * if (edge) {
     *   console.log(edge);
     * } else {
     *   console.error("Edge does not exist");
     * }
     * ```
     */
    edge(selector: documents.DocumentSelector, graceful: boolean): Promise<documents.Edge<EntryResultType>>;
    /**
     * Inserts a new edge with the given `data` into the collection.
     *
     * @param data - The contents of the new edge.
     * @param options - Options for inserting the edge.
     *
     * @example
     * ```js
     * const db = new Database();
     * const collection = db.collection("friends");
     * const result = await collection.save(
     *   { _from: "users/rana", _to: "users/mudasir", active: false },
     *   { returnNew: true }
     * );
     * ```
     */
    save(data: documents.EdgeData<EntryInputType>, options?: InsertGraphDocumentOptions): Promise<documents.DocumentMetadata & {
        new?: documents.Edge<EntryResultType>;
    }>;
    /**
     * Replaces an existing edge in the collection.
     *
     * Throws an exception when passed a edge or `_id` from a different
     * collection.
     *
     * @param selector - Document `_key`, `_id` or object with either of those
     * properties (e.g. a edge from this collection).
     * @param newData - The contents of the new edge.
     * @param options - Options for replacing the edge.
     *
     * @example
     * ```js
     * const db = new Database();
     * const collection = db.collection("friends");
     * await collection.save(
     *   {
     *     _key: "musadir",
     *     _from: "users/rana",
     *     _to: "users/mudasir",
     *     active: true,
     *     best: true
     *   }
     * );
     * const result = await collection.replace(
     *   "musadir",
     *   { active: false },
     *   { returnNew: true }
     * );
     * console.log(result.new.active, result.new.best); // false undefined
     * ```
     */
    replace(selector: documents.DocumentSelector, newData: documents.EdgeData<EntryInputType>, options?: ReplaceGraphDocumentOptions): Promise<documents.DocumentMetadata & {
        new?: documents.Edge<EntryResultType>;
        old?: documents.Edge<EntryResultType>;
    }>;
    /**
     * Updates an existing edge in the collection.
     *
     * Throws an exception when passed a edge or `_id` from a different
     * collection.
     *
     * @param selector - Document `_key`, `_id` or object with either of those
     * properties (e.g. a edge from this collection).
     * @param newData - The data for updating the edge.
     * @param options - Options for updating the edge.
     *
     * @example
     * ```js
     * const db = new Database();
     * const collection = db.collection("friends");
     * await collection.save(
     *   {
     *     _key: "musadir",
     *     _from: "users/rana",
     *     _to: "users/mudasir",
     *     active: true,
     *     best: true
     *   }
     * );
     * const result = await collection.update(
     *   "musadir",
     *   { active: false },
     *   { returnNew: true }
     * );
     * console.log(result.new.active, result.new.best); // false true
     * ```
     */
    update(selector: documents.DocumentSelector, newData: documents.Patch<documents.EdgeData<EntryInputType>>, options?: ReplaceGraphDocumentOptions): Promise<documents.DocumentMetadata & {
        new?: documents.Edge<EntryResultType>;
        old?: documents.Edge<EntryResultType>;
    }>;
    /**
     * Removes an existing edge from the collection.
     *
     * Throws an exception when passed a edge or `_id` from a different
     * collection.
     *
     * @param selector - Document `_key`, `_id` or object with either of those
     * properties (e.g. a edge from this collection).
     * @param options - Options for removing the edge.
     *
     * @example
     * ```js
     * const db = new Database();
     * const collection = db.collection("friends");
     * const doc = await collection.edge("musadir");
     * await collection.remove(doc);
     * // edge with key "musadir" deleted
     * ```
     */
    remove(selector: documents.DocumentSelector, options?: RemoveGraphDocumentOptions): Promise<documents.DocumentMetadata & {
        old?: documents.Edge<EntryResultType>;
    }>;
}
/**
 * Indicates whether the given value represents a {@link Graph}.
 *
 * @param graph - A value that might be a Graph.
 */
export declare function isArangoGraph(graph: any): graph is Graph;
/**
 * Represents a graph in a {@link databases.Database}.
 */
export declare class Graph {
    protected _name: string;
    protected _db: databases.Database;
    /**
     * @internal
     */
    constructor(db: databases.Database, name: string);
    /**
     * Indicates that this object represents an ArangoDB Graph.
     */
    get isArangoGraph(): true;
    /**
     * Database this graph belongs to.
     */
    get database(): databases.Database;
    /**
     * Name of the graph.
     */
    get name(): string;
    /**
     * Checks whether the graph exists.
     *
     * @example
     * ```js
     * const db = new Database();
     * const graph = db.graph("some-graph");
     * const result = await graph.exists();
     * // result indicates whether the graph exists
     * ```
     */
    exists(): Promise<boolean>;
    /**
     * Retrieves general information about the graph.
     *
     * @example
     * ```js
     * const db = new Database();
     * const graph = db.graph("some-graph");
     * const data = await graph.get();
     * // data contains general information about the graph
     * ```
     */
    get(): Promise<GraphDescription>;
    /**
     * Creates a graph with the given `edgeDefinitions` and `options` for this
     * graph's name.
     *
     * @param edgeDefinitions - Definitions for the relations of the graph.
     * @param options - Options for creating the graph.
     *
     * @example
     * ```js
     * const db = new Database();
     * const graph = db.graph("some-graph");
     * const info = await graph.create([
     *   {
     *     collection: "edges",
     *     from: ["start-vertices"],
     *     to: ["end-vertices"],
     *   },
     * ]);
     * // graph now exists
     * ```
     */
    create(edgeDefinitions: EdgeDefinitionOptions[], options?: CreateGraphOptions): Promise<GraphDescription>;
    /**
     * Deletes the graph from the database.
     *
     * @param dropCollections - If set to `true`, the collections associated with
     * the graph will also be deleted.
     *
     * @example
     * ```js
     * const db = new Database();
     * const graph = db.graph("some-graph");
     * await graph.drop();
     * // the graph "some-graph" no longer exists
     * ```
     */
    drop(dropCollections?: boolean): Promise<boolean>;
    /**
     * Returns a {@link GraphVertexCollection} instance for the given collection
     * name representing the collection in this graph.
     *
     * @param T - Type to use for document data. Defaults to `any`.
     * @param collection - Name of the vertex collection.
     */
    vertexCollection<T extends Record<string, any> = any>(collection: string | collections.ArangoCollection): GraphVertexCollection<T>;
    /**
     * Fetches all vertex collections of this graph from the database and returns
     * an array of their names.
     *
     * See also {@link Graph#vertexCollections}.
     *
     * @example
     * ```js
     * const db = new Database();
     * const graph = db.graph("some-graph");
     * const info = await graph.create([
     *   {
     *     collection: "edges",
     *     from: ["start-vertices"],
     *     to: ["end-vertices"],
     *   },
     * ]);
     * const vertexCollectionNames = await graph.listVertexCollections();
     * // ["start-vertices", "end-vertices"]
     * ```
     */
    listVertexCollections(): Promise<string[]>;
    /**
     * Fetches all vertex collections of this graph from the database and returns
     * an array of {@link GraphVertexCollection} instances.
     *
     * See also {@link Graph#listVertexCollections}.
     *
     * @example
     * ```js
     * const db = new Database();
     * const graph = db.graph("some-graph");
     * const info = await graph.create([
     *   {
     *     collection: "edges",
     *     from: ["start-vertices"],
     *     to: ["end-vertices"],
     *   },
     * ]);
     * const vertexCollections = await graph.vertexCollections();
     * for (const vertexCollection of vertexCollections) {
     *   console.log(vertexCollection.name);
     *   // "start-vertices"
     *   // "end-vertices"
     * }
     * ```
     */
    vertexCollections(): Promise<GraphVertexCollection[]>;
    /**
     * Adds the given collection to this graph as a vertex collection.
     *
     * @param collection - Collection to add to the graph.
     *
     * @example
     * ```js
     * const db = new Database();
     * const graph = db.graph("some-graph");
     * await graph.addVertexCollection("more-vertices");
     * // The collection "more-vertices" has been added to the graph
     * const extra = db.collection("extra-vertices");
     * await graph.addVertexCollection(extra);
     * // The collection "extra-vertices" has been added to the graph
     * ```
     */
    addVertexCollection(collection: string | collections.ArangoCollection, options?: AddVertexCollectionOptions): Promise<GraphDescription>;
    /**
     * Removes the given collection from this graph as a vertex collection.
     *
     * @param collection - Collection to remove from the graph.
     * @param dropCollection - If set to `true`, the collection will also be
     * deleted from the database.
     *
     * @example
     * ```js
     * const db = new Database();
     * const graph = db.graph("some-graph");
     * const info = await graph.create([
     *   {
     *     collection: "edges",
     *     from: ["start-vertices"],
     *     to: ["end-vertices"],
     *   },
     * ]);
     * await graph.removeVertexCollection("start-vertices");
     * // The collection "start-vertices" is no longer part of the graph.
     * ```
     */
    removeVertexCollection(collection: string | collections.ArangoCollection, dropCollection?: boolean): Promise<GraphDescription>;
    /**
     * Returns a {@link GraphEdgeCollection} instance for the given collection
     * name representing the collection in this graph.
     *
     * @param T - Type to use for document data. Defaults to `any`.
     * @param collection - Name of the edge collection.
     *
     * @example
     * ```js
     * const db = new Database();
     * const graph = db.graph("some-graph");
     * const info = await graph.create([
     *   {
     *     collection: "edges",
     *     from: ["start-vertices"],
     *     to: ["end-vertices"],
     *   },
     * ]);
     * const graphEdgeCollection = graph.edgeCollection("edges");
     * // Access the underlying EdgeCollection API:
     * const edgeCollection = graphEdgeCollection.collection;
     * ```
     */
    edgeCollection<T extends Record<string, any> = any>(collection: string | collections.ArangoCollection): GraphEdgeCollection<T>;
    /**
     * Fetches all edge collections of this graph from the database and returns
     * an array of their names.
     *
     * See also {@link Graph#edgeCollections}.
     *
     * @example
     * ```js
     * const db = new Database();
     * const graph = db.graph("some-graph");
     * const info = await graph.create([
     *   {
     *     collection: "edges",
     *     from: ["start-vertices"],
     *     to: ["end-vertices"],
     *   },
     * ]);
     * const edgeCollectionNames = await graph.listEdgeCollections();
     * // ["edges"]
     * ```
     */
    listEdgeCollections(): Promise<string[]>;
    /**
     * Fetches all edge collections of this graph from the database and returns
     * an array of {@link GraphEdgeCollection} instances.
     *
     * See also {@link Graph#listEdgeCollections}.
     *
     * @example
     * ```js
     * const db = new Database();
     * const graph = db.graph("some-graph");
     * const info = await graph.create([
     *   {
     *     collection: "edges",
     *     from: ["start-vertices"],
     *     to: ["end-vertices"],
     *   },
     * ]);
     * const graphEdgeCollections = await graph.edgeCollections();
     * for (const collection of graphEdgeCollection) {
     *   console.log(collection.name);
     *   // "edges"
     * }
     * ```
     */
    edgeCollections(): Promise<GraphEdgeCollection[]>;
    /**
     * Adds an edge definition to this graph.
     *
     * @param edgeDefinition - Definition of a relation in this graph.
     *
     * @example
     * ```js
     * const db = new Database();
     * const graph = db.graph("some-graph");
     * await graph.addEdgeDefinition({
     *   collection: "edges",
     *   from: ["start-vertices"],
     *   to: ["end-vertices"],
     * });
     * // The edge definition has been added to the graph
     * ```
     */
    addEdgeDefinition(edgeDefinition: EdgeDefinitionOptions, options?: AddEdgeDefinitionOptions): Promise<GraphDescription>;
    /**
     * Replaces an edge definition in this graph. The existing edge definition
     * for the given edge collection will be overwritten.
     *
     * @param edgeDefinition - Definition of a relation in this graph.
     *
     * @example
     * ```js
     * const db = new Database();
     * const graph = db.graph("some-graph");
     * const info = await graph.create([
     *   {
     *     collection: "edges",
     *     from: ["start-vertices"],
     *     to: ["end-vertices"],
     *   },
     * ]);
     * await graph.replaceEdgeDefinition({
     *   collection: "edges",
     *   from: ["start-vertices"],
     *   to: ["other-vertices"],
     * });
     * // The edge definition for "edges" has been replaced
     * ```
     */
    replaceEdgeDefinition(edgeDefinition: EdgeDefinitionOptions, options?: ReplaceEdgeDefinitionOptions): Promise<GraphDescription>;
    /**
     * Replaces an edge definition in this graph. The existing edge definition
     * for the given edge collection will be overwritten.
     *
     * @param collection - Edge collection for which to replace the definition.
     * @param edgeDefinition - Definition of a relation in this graph.
     *
     * @example
     * ```js
     * const db = new Database();
     * const graph = db.graph("some-graph");
     * const info = await graph.create([
     *   {
     *     collection: "edges",
     *     from: ["start-vertices"],
     *     to: ["end-vertices"],
     *   },
     * ]);
     * await graph.replaceEdgeDefinition("edges", {
     *   collection: "edges",
     *   from: ["start-vertices"],
     *   to: ["other-vertices"],
     * });
     * // The edge definition for "edges" has been replaced
     * ```
     */
    replaceEdgeDefinition(collection: string | collections.ArangoCollection, edgeDefinition: EdgeDefinitionOptions, options?: ReplaceEdgeDefinitionOptions): Promise<GraphDescription>;
    /**
     * Removes the edge definition for the given edge collection from this graph.
     *
     * @param collection - Edge collection for which to remove the definition.
     * @param dropCollection - If set to `true`, the collection will also be
     * deleted from the database.
     *
     * @example
     * ```js
     * const db = new Database();
     * const graph = db.graph("some-graph");
     * const info = await graph.create([
     *   {
     *     collection: "edges",
     *     from: ["start-vertices"],
     *     to: ["end-vertices"],
     *   },
     * ]);
     * await graph.removeEdgeDefinition("edges");
     * // The edge definition for "edges" has been replaced
     * ```
     */
    removeEdgeDefinition(collection: string | collections.ArangoCollection, dropCollection?: boolean): Promise<GraphDescription>;
}
//# sourceMappingURL=graphs.d.ts.map