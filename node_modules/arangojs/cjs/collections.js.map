{"version":3,"file":"collections.js","sourceRoot":"","sources":["../../src/collections.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * ```ts\n * import type {\n *   DocumentCollection,\n *   EdgeCollection,\n * } from \"arangojs/collections\";\n * ```\n *\n * The \"collections\" module provides collection related types and interfaces\n * for TypeScript.\n *\n * @packageDocumentation\n */\nimport * as aql from \"./aql.js\";\nimport * as connection from \"./connection.js\";\nimport * as databases from \"./databases.js\";\nimport * as documents from \"./documents.js\";\nimport * as errors from \"./errors.js\";\nimport * as indexes from \"./indexes.js\";\nimport { COLLECTION_NOT_FOUND, DOCUMENT_NOT_FOUND } from \"./lib/codes.js\";\n\n//#region ArangoCollection interface\n/**\n * Indicates whether the given value represents an {@link ArangoCollection}.\n *\n * @param collection - A value that might be a collection.\n */\nexport function isArangoCollection(\n  collection: any\n): collection is ArangoCollection {\n  return Boolean(collection && collection.isArangoCollection);\n}\n\n/**\n * Coerces the given collection name or {@link ArangoCollection} object to\n * a string representing the collection name.\n *\n * @param collection - Collection name or {@link ArangoCollection} object.\n */\nexport function collectionToString(\n  collection: string | ArangoCollection\n): string {\n  if (isArangoCollection(collection)) {\n    return String(collection.name);\n  } else return String(collection);\n}\n\n/**\n * A marker interface identifying objects that can be used in AQL template\n * strings to create references to ArangoDB collections.\n *\n * See {@link aql.aql}.\n */\nexport interface ArangoCollection {\n  /**\n   * @internal\n   *\n   * Indicates that this object represents an ArangoDB collection.\n   */\n  readonly isArangoCollection: true;\n  /**\n   * Name of the collection.\n   */\n  readonly name: string;\n}\n//#endregion\n\n//#region Shared types\n/**\n * Integer values indicating the collection type.\n */\nexport enum CollectionType {\n  DOCUMENT_COLLECTION = 2,\n  EDGE_COLLECTION = 3,\n}\n\n/**\n * Integer values indicating the collection loading status.\n */\nexport enum CollectionStatus {\n  NEWBORN = 1,\n  UNLOADED = 2,\n  LOADED = 3,\n  UNLOADING = 4,\n  DELETED = 5,\n  LOADING = 6,\n}\n\n/**\n * Type of key generator.\n */\nexport type KeyGenerator = \"traditional\" | \"autoincrement\" | \"uuid\" | \"padded\";\n\n/**\n * Strategy for sharding a collection.\n */\nexport type ShardingStrategy =\n  | \"hash\"\n  | \"enterprise-hash-smart-edge\"\n  | \"enterprise-hash-smart-vertex\"\n  | \"community-compat\"\n  | \"enterprise-compat\"\n  | \"enterprise-smart-edge-compat\";\n\n/**\n * When a validation should be applied.\n *\n * * `\"none\"`: No validation.\n * * `\"new\"`: Newly inserted documents are validated.\n * * `\"moderate\"`: New and modified documents are validated unless the modified\n *   document was already invalid.\n * * `\"strict\"`: New and modified documents are always validated.\n */\nexport type ValidationLevel = \"none\" | \"new\" | \"moderate\" | \"strict\";\n\n/**\n * Write operation that can result in a computed value being computed.\n */\nexport type WriteOperation = \"insert\" | \"update\" | \"replace\";\n//#endregion\n\n//#region Collection operation options\n/**\n * Options for creating a collection.\n *\n * See {@link databases.Database#createCollection}, {@link databases.Database#createEdgeCollection}\n * and {@link DocumentCollection#create} or {@link EdgeCollection#create}.\n */\nexport type CreateCollectionOptions = CollectionPropertiesOptions & {\n  /**\n   * @internal\n   *\n   * Whether the collection should be created as a system collection.\n   *\n   * Default: `false`\n   */\n  isSystem?: boolean;\n  /**\n   * An object defining the collection's key generation.\n   */\n  keyOptions?: CollectionKeyOptions;\n  /**\n   * (Cluster only.) Unless set to `false`, the server will wait for all\n   * replicas to create the collection before returning.\n   *\n   * Default: `true`\n   */\n  waitForSyncReplication?: boolean;\n  /**\n   * (Cluster only.) Unless set to `false`, the server will check whether\n   * enough replicas are available at creation time and bail out otherwise.\n   *\n   * Default: `true`\n   */\n  enforceReplicationFactor?: boolean;\n  /**\n   * (Cluster only.) Number of shards to distribute the collection across.\n   *\n   * Default: `1`\n   */\n  numberOfShards?: number;\n  /**\n   * (Cluster only.) Document attributes to use to determine the target shard\n   * for each document.\n   *\n   * Default: `[\"_key\"]`\n   */\n  shardKeys?: string[];\n  /**\n   * (Cluster only.) Sharding strategy to use.\n   */\n  shardingStrategy?: ShardingStrategy;\n  /**\n   * (Enterprise Edition cluster only.) If set to a collection name, sharding\n   * of the new collection will follow the rules for that collection. As long\n   * as the new collection exists, the indicated collection can not be dropped.\n   */\n  distributeShardsLike?: string;\n  /**\n   * (Enterprise Edition cluster only.) Attribute containing the shard key\n   * value of the referred-to smart join collection.\n   */\n  smartJoinAttribute?: string;\n  /**\n   * (Enterprise Edition cluster only.) Attribute used for sharding.\n   */\n  smartGraphAttribute?: string;\n};\n\n/**\n * An object defining the collection's key generation.\n */\nexport type CollectionKeyOptions = {\n  /**\n   * Type of key generator to use.\n   */\n  type?: KeyGenerator;\n  /**\n   * Unless set to `false`, documents can be created with a user-specified\n   * `_key` attribute.\n   *\n   * Default: `true`\n   */\n  allowUserKeys?: boolean;\n  /**\n   * (Autoincrement only.) How many steps to increment the key each time.\n   */\n  increment?: number;\n  /**\n   * (Autoincrement only.) Initial offset for the key.\n   */\n  offset?: number;\n};\n\n/**\n * Options for setting a collection's properties.\n *\n * See {@link DocumentCollection#properties} and {@link EdgeCollection#properties}.\n */\nexport type CollectionPropertiesOptions = {\n  /**\n   * If set to `true`, data will be synchronized to disk before returning from\n   * a document create, update, replace or removal operation.\n   *\n   * Default: `false`\n   */\n  waitForSync?: boolean;\n  /**\n   * (Cluster only.) How many copies of each document should be kept in the\n   * cluster.\n   *\n   * Default: `1`\n   */\n  replicationFactor?: number | \"satellite\";\n  /**\n   * (Cluster only.) Write concern for this collection.\n   */\n  writeConcern?: number;\n  /**\n   * Options for validating documents in this collection.\n   */\n  schema?: SchemaOptions;\n  /**\n   * Computed values to apply to documents in this collection.\n   */\n  computedValues?: ComputedValueOptions[];\n  /**\n   * Whether the in-memory hash cache is enabled for this collection.\n   *\n   * Default: `false`\n   */\n  cacheEnabled?: boolean;\n};\n\n/**\n * Options for validating collection documents.\n */\nexport type SchemaOptions = {\n  /**\n   * JSON Schema description of the validation schema for documents.\n   */\n  rule: any;\n  /**\n   * When validation should be applied.\n   *\n   * Default: `\"strict\"`\n   */\n  level?: ValidationLevel;\n  /**\n   * Message to be used if validation fails.\n   */\n  message?: string;\n};\n\n/**\n * Options for creating a computed value.\n */\nexport type ComputedValueOptions = {\n  /**\n   * Name of the target attribute of the computed value.\n   */\n  name: string;\n  /**\n   * AQL `RETURN` expression that computes the value.\n   *\n   * Note that when passing an AQL query object, the `bindVars` will be ignored.\n   */\n  expression: string | aql.AqlLiteral | aql.AqlQuery;\n  /**\n   * If set to `false`, the computed value will not be applied if the\n   * expression evaluates to `null`.\n   *\n   * Default: `true`\n   */\n  overwrite?: boolean;\n  /**\n   * Which operations should result in the value being computed.\n   *\n   * Default: `[\"insert\", \"update\", \"replace\"]`\n   */\n  computeOn?: WriteOperation[];\n  /**\n   * If set to `false`, the field will be unset if the expression evaluates to\n   * `null`. Otherwise the field will be set to the value `null`. Has no effect\n   * if `overwrite` is set to `false`.\n   *\n   * Default: `true`\n   */\n  keepNull?: boolean;\n  /**\n   * Whether the write operation should fail if the expression produces a\n   * warning.\n   *\n   * Default: `false`\n   */\n  failOnWarning?: boolean;\n};\n\n/**\n * Options for retrieving a collection checksum.\n */\nexport type CollectionChecksumOptions = {\n  /**\n   * If set to `true`, revision IDs will be included in the calculation\n   * of the checksum.\n   *\n   * Default: `false`\n   */\n  withRevisions?: boolean;\n  /**\n   * If set to `true`, document data will be included in the calculation\n   * of the checksum.\n   *\n   * Default: `false`\n   */\n  withData?: boolean;\n};\n\n/**\n * Options for truncating collections.\n */\nexport type TruncateCollectionOptions = {\n  /**\n   * Whether the collection should be compacted after truncation.\n   */\n  compact?: boolean;\n  /**\n   * Whether data should be synchronized to disk before returning from this\n   * operation.\n   */\n  waitForSync?: boolean;\n};\n\n/**\n * Options for dropping collections.\n */\nexport type DropCollectionOptions = {\n  /**\n   * Whether the collection is a system collection. If the collection is a\n   * system collection, this option must be set to `true` or ArangoDB will\n   * refuse to drop the collection.\n   *\n   * Default: `false`\n   */\n  isSystem?: boolean;\n};\n//#endregion\n\n//#region CollectionDescription\n/**\n * General information about a collection.\n */\nexport type CollectionDescription = {\n  /**\n   * Collection name.\n   */\n  name: string;\n  /**\n   * A globally unique identifier for this collection.\n   */\n  globallyUniqueId: string;\n  /**\n   * An integer indicating the collection loading status.\n   */\n  status: CollectionStatus;\n  /**\n   * An integer indicating the collection type.\n   */\n  type: CollectionType;\n  /**\n   * @internal\n   *\n   * Whether the collection is a system collection.\n   */\n  isSystem: boolean;\n};\n//#endregion\n\n//#region CollectionProperties\n/**\n * An object defining the properties of a collection.\n */\nexport type CollectionProperties = {\n  /**\n   * A human-readable representation of the collection loading status.\n   */\n  statusString: string;\n  /**\n   * Whether data should be synchronized to disk before returning from\n   * a document create, update, replace or removal operation.\n   */\n  waitForSync: boolean;\n  /**\n   * An object defining the collection's key generation.\n   */\n  keyOptions: CollectionKeyProperties;\n  /**\n   * Properties for validating documents in the collection.\n   */\n  schema: SchemaProperties | null;\n  /**\n   * (Cluster only.) Write concern for this collection.\n   */\n  writeConcern: number;\n  /**\n   * (Cluster only.) Number of shards of this collection.\n   */\n  numberOfShards?: number;\n  /**\n   * (Cluster only.) Keys of this collection that will be used for\n   * sharding.\n   */\n  shardKeys?: string[];\n  /**\n   * (Cluster only.) Replication factor of the collection.\n   */\n  replicationFactor?: number | \"satellite\";\n  /**\n   * (Cluster only.) Sharding strategy of the collection.\n   */\n  shardingStrategy?: ShardingStrategy;\n  /**\n   * (Enterprise Edition cluster only.) If set to a collection name, sharding\n   * of the new collection will follow the rules for that collection. As long\n   * as the new collection exists, the indicated collection can not be dropped.\n   */\n  distributeShardsLike?: string;\n  /**\n   * (Enterprise Edition cluster only.) Attribute containing the shard key\n   * value of the referred-to smart join collection.\n   */\n  smartJoinAttribute?: string;\n  /**\n   * (Enterprise Edition cluster only.) Attribute used for sharding.\n   */\n  smartGraphAttribute?: string;\n  /**\n   * Computed values applied to documents in this collection.\n   */\n  computedValues: ComputedValueProperties[];\n  /**\n   * Whether the in-memory hash cache is enabled for this collection.\n   */\n  cacheEnabled: boolean;\n  /**\n   * Whether the newer revision-based replication protocol is enabled for\n   * this collection.\n   */\n  syncByRevision: boolean;\n  /**\n   * (Enterprise Edition only.) Whether the collection is used in a SmartGraph or EnterpriseGraph.\n   */\n  isSmart?: boolean;\n  /**\n   * (Enterprise Edition only.) Whether the SmartGraph this collection belongs to is disjoint.\n   */\n  isDisjoint?: string;\n};\n\n/**\n * An object defining the collection's key generation.\n */\nexport type CollectionKeyProperties = {\n  /**\n   * Type of key generator to use.\n   */\n  type: KeyGenerator;\n  /**\n   * Whether documents can be created with a user-specified `_key` attribute.\n   */\n  allowUserKeys: boolean;\n  /**\n   * (Autoincrement only.) How many steps to increment the key each time.\n   */\n  increment?: number;\n  /**\n   * (Autoincrement only.) Initial offset for the key.\n   */\n  offset?: number;\n  /**\n   * Most recent key that has been generated.\n   */\n  lastValue: number;\n};\n\n/**\n * Properties for validating documents in a collection.\n */\nexport type SchemaProperties = {\n  /**\n   * Type of document validation.\n   */\n  type: \"json\";\n  /**\n   * JSON Schema description of the validation schema for documents.\n   */\n  rule: any;\n  /**\n   * When validation should be applied.\n   */\n  level: ValidationLevel;\n  /**\n   * Message to be used if validation fails.\n   */\n  message: string;\n};\n\n/**\n * Properties defining a computed value.\n */\nexport type ComputedValueProperties = {\n  /**\n   * Name of the target attribute of the computed value.\n   */\n  name: string;\n  /**\n   * AQL `RETURN` expression that computes the value.\n   */\n  expression: string;\n  /**\n   * If set to `false`, the computed value will not be applied if the\n   * expression evaluates to `null`.\n   */\n  overwrite: boolean;\n  /**\n   * Which operations should result in the value being computed.\n   */\n  computeOn: WriteOperation[];\n  /**\n   * If set to `false`, the field will be unset if the expression evaluates to\n   * `null`. Otherwise the field will be set to the value `null`. Has no effect\n   * if `overwrite` is set to `false`.\n   */\n  keepNull: boolean;\n  /**\n   * Whether the write operation should fail if the expression produces a\n   * warning.\n   */\n  failOnWarning: boolean;\n};\n//#endregion\n\n//#region DocumentCollection interface\n/**\n * Represents an document collection in a {@link databases.Database}.\n *\n * See {@link EdgeCollection} for a variant of this interface more suited for\n * edge collections.\n *\n * When using TypeScript, collections can be cast to a specific document data\n * type to increase type safety.\n *\n * @param EntryResultType - Type to represent document contents returned by the\n * server (including computed properties).\n * @param EntryInputType - Type to represent document contents passed when\n * inserting or replacing documents (without computed properties).\n *\n * @example\n * ```ts\n * interface Person {\n *   name: string;\n * }\n * const db = new Database();\n * const documents = db.collection(\"persons\") as DocumentCollection<Person>;\n * ```\n */\nexport interface DocumentCollection<\n  EntryResultType extends Record<string, any> = any,\n  EntryInputType extends Record<string, any> = EntryResultType,\n> extends ArangoCollection {\n  /**\n   * Database this collection belongs to.\n   */\n  readonly database: databases.Database;\n  //#region Collection operations\n  /**\n   * Checks whether the collection exists.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const result = await collection.exists();\n   * // result indicates whether the collection exists\n   * ```\n   */\n  exists(): Promise<boolean>;\n  /**\n   * Retrieves general information about the collection.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const data = await collection.get();\n   * // data contains general information about the collection\n   * ```\n   */\n  get(): Promise<connection.ArangoApiResponse<CollectionDescription>>;\n  /**\n   * Creates a collection with the given `options` and the instance's name.\n   *\n   * See also {@link databases.Database#createCollection} and\n   * {@link databases.Database#createEdgeCollection}.\n   *\n   * **Note**: When called on an {@link EdgeCollection} instance in TypeScript,\n   * the `type` option must still be set to the correct {@link CollectionType}.\n   * Otherwise this will result in the collection being created with the\n   * default type (i.e. as a document collection).\n   *\n   * @param options - Options for creating the collection.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"potatoes\");\n   * await collection.create();\n   * // the document collection \"potatoes\" now exists\n   * ```\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"friends\");\n   * await collection.create({ type: CollectionType.EDGE_COLLECTION });\n   * // the edge collection \"friends\" now exists\n   * ```\n   *\n   * @example\n   * ```ts\n   * interface Friend {\n   *   startDate: number;\n   *   endDate?: number;\n   * }\n   * const db = new Database();\n   * const collection = db.collection(\"friends\") as EdgeCollection<Friend>;\n   * // even in TypeScript you still need to indicate the collection type\n   * // if you want to create an edge collection\n   * await collection.create({ type: CollectionType.EDGE_COLLECTION });\n   * // the edge collection \"friends\" now exists\n   * ```\n   */\n  create(\n    options?: CreateCollectionOptions & {\n      type?: CollectionType;\n    }\n  ): Promise<\n    connection.ArangoApiResponse<CollectionDescription & CollectionProperties>\n  >;\n  /**\n   * Retrieves the collection's properties.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const data = await collection.properties();\n   * // data contains the collection's properties\n   * ```\n   */\n  properties(): Promise<\n    connection.ArangoApiResponse<CollectionDescription & CollectionProperties>\n  >;\n  /**\n   * Replaces the properties of the collection.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const result = await collection.setProperties({ waitForSync: true });\n   * // the collection will now wait for data being written to disk\n   * // whenever a document is changed\n   * ```\n   */\n  properties(\n    properties: CollectionPropertiesOptions\n  ): Promise<\n    connection.ArangoApiResponse<CollectionDescription & CollectionProperties>\n  >;\n  /**\n   * Retrieves information about the number of documents in a collection.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const data = await collection.count();\n   * // data contains the collection's count\n   * ```\n   */\n  count(): Promise<\n    connection.ArangoApiResponse<\n      CollectionDescription & CollectionProperties & { count: number }\n    >\n  >;\n  /**\n   * Instructs ArangoDB to recalculate the collection's document count to fix\n   * any inconsistencies.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"inconsistent-collection\");\n   * const badData = await collection.count();\n   * // oh no, the collection count looks wrong -- fix it!\n   * await collection.recalculateCount();\n   * const goodData = await collection.count();\n   * // goodData contains the collection's improved count\n   * ```\n   */\n  recalculateCount(): Promise<boolean>;\n  /**\n   * Retrieves statistics for a collection.\n   *\n   * @param details - whether to return extended storage engine-specific details\n   * to the figures, which may cause additional load and impact performance\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const data = await collection.figures();\n   * // data contains the collection's figures\n   * ```\n   */\n  figures(\n    details?: boolean\n  ): Promise<\n    connection.ArangoApiResponse<\n      CollectionDescription &\n        CollectionProperties & { count: number; figures: Record<string, any> }\n    >\n  >;\n  /**\n   * Retrieves the collection revision ID.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const data = await collection.revision();\n   * // data contains the collection's revision\n   * ```\n   */\n  revision(): Promise<\n    connection.ArangoApiResponse<\n      CollectionDescription & CollectionProperties & { revision: string }\n    >\n  >;\n  /**\n   * Retrieves the collection checksum.\n   *\n   * @param options - Options for retrieving the checksum.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const data = await collection.checksum();\n   * // data contains the collection's checksum\n   * ```\n   */\n  checksum(\n    options?: CollectionChecksumOptions\n  ): Promise<\n    connection.ArangoApiResponse<\n      CollectionDescription & { revision: string; checksum: string }\n    >\n  >;\n  /**\n   * Retrieves the collection's shard IDs.\n   *\n   * @param details - If set to `true`, the response will include the responsible\n   * servers for each shard.\n   */\n  shards(\n    details?: false\n  ): Promise<\n    connection.ArangoApiResponse<\n      CollectionDescription & CollectionProperties & { shards: string[] }\n    >\n  >;\n  /**\n   * Retrieves the collection's shard IDs and the responsible servers for each\n   * shard.\n   *\n   * @param details - If set to `false`, the response will only include the\n   * shard IDs without the responsible servers for each shard.\n   */\n  shards(\n    details: true\n  ): Promise<\n    connection.ArangoApiResponse<\n      CollectionDescription &\n        CollectionProperties & { shards: Record<string, string[]> }\n    >\n  >;\n  /**\n   * Retrieves the collection's shard IDs.\n   *\n   * @param details - If set to `true`, the response will include the responsible\n   * servers for each shard.\n   */\n  shards(\n    details?: false\n  ): Promise<\n    connection.ArangoApiResponse<\n      CollectionDescription & CollectionProperties & { shards: string[] }\n    >\n  >;\n  /**\n   * Retrieves the collection's shard IDs and the responsible servers for each\n   * shard.\n   *\n   * @param details - If set to `false`, the response will only include the\n   * shard IDs without the responsible servers for each shard.\n   */\n  shards(\n    details: true\n  ): Promise<\n    connection.ArangoApiResponse<\n      CollectionDescription &\n        CollectionProperties & { shards: Record<string, string[]> }\n    >\n  >;\n  /**\n   * Renames the collection and updates the instance's `name` to `newName`.\n   *\n   * Additionally removes the instance from the {@link databases.Database}'s internal\n   * cache.\n   *\n   * **Note**: Renaming collections may not be supported when ArangoDB is\n   * running in a cluster configuration.\n   *\n   * @param newName - The new name of the collection.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection1 = db.collection(\"some-collection\");\n   * await collection1.rename(\"other-collection\");\n   * const collection2 = db.collection(\"some-collection\");\n   * const collection3 = db.collection(\"other-collection\");\n   * // Note all three collection instances are different objects but\n   * // collection1 and collection3 represent the same ArangoDB collection!\n   * ```\n   */\n  rename(\n    newName: string\n  ): Promise<connection.ArangoApiResponse<CollectionDescription>>;\n  /**\n   * Deletes all documents in the collection.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.truncate();\n   * // millions of documents cry out in terror and are suddenly silenced,\n   * // the collection \"some-collection\" is now empty\n   * ```\n   */\n  truncate(\n    options?: TruncateCollectionOptions\n  ): Promise<connection.ArangoApiResponse<CollectionDescription>>;\n  /**\n   * Deletes the collection from the database.\n   *\n   * @param options - Options for dropping the collection.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.drop();\n   * // The collection \"some-collection\" is now an ex-collection\n   * ```\n   */\n  drop(\n    options?: DropCollectionOptions\n  ): Promise<connection.ArangoApiResponse<{ id: string }>>;\n  /**\n   * Triggers compaction for a collection.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.compact();\n   * // Background compaction is triggered on the collection\n   * ```\n   */\n  compact(): Promise<connection.ArangoApiResponse<CollectionDescription>>;\n  //#endregion\n\n  //#region Document operations\n  /**\n   * Retrieves the `shardId` of the shard responsible for the given document.\n   *\n   * @param document - Document in the collection to look up the `shardId` of.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const responsibleShard = await collection.getResponsibleShard();\n   * ```\n   */\n  getResponsibleShard(\n    document: Partial<documents.Document<EntryResultType>>\n  ): Promise<string>;\n  /**\n   * Derives a document `_id` from the given selector for this collection.\n   *\n   * Throws an exception when passed a document or `_id` from a different\n   * collection.\n   *\n   * @param selector - Document `_key`, `_id` or object with either of those\n   * properties (e.g. a document from this collection).\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const meta = await collection.save({ foo: \"bar\" }, { returnNew: true });\n   * const doc = meta.new;\n   * console.log(collection.documentId(meta)); // via meta._id\n   * console.log(collection.documentId(doc)); // via doc._id\n   * console.log(collection.documentId(meta._key)); // also works\n   * ```\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection1 = db.collection(\"some-collection\");\n   * const collection2 = db.collection(\"other-collection\");\n   * const meta = await collection1.save({ foo: \"bar\" });\n   * // Mixing collections is usually a mistake\n   * console.log(collection1.documentId(meta)); // ok: same collection\n   * console.log(collection2.documentId(meta)); // throws: wrong collection\n   * console.log(collection2.documentId(meta._id)); // also throws\n   * console.log(collection2.documentId(meta._key)); // ok but wrong collection\n   * ```\n   */\n  documentId(selector: documents.DocumentSelector): string;\n  /**\n   * Checks whether a document matching the given key or id exists in this\n   * collection.\n   *\n   * Throws an exception when passed a document or `_id` from a different\n   * collection.\n   *\n   * @param selector - Document `_key`, `_id` or object with either of those\n   * properties (e.g. a document from this collection).\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const exists = await collection.documentExists(\"abc123\");\n   * if (!exists) {\n   *   console.log(\"Document does not exist\");\n   * }\n   * ```\n   */\n  documentExists(\n    selector: documents.DocumentSelector,\n    options?: documents.DocumentExistsOptions\n  ): Promise<boolean>;\n  /**\n   * Retrieves the document matching the given key or id.\n   *\n   * Throws an exception when passed a document or `_id` from a different\n   * collection.\n   *\n   * @param selector - Document `_key`, `_id` or object with either of those\n   * properties (e.g. a document from this collection).\n   * @param options - Options for retrieving the document.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * try {\n   *   const document = await collection.document(\"abc123\");\n   *   console.log(document);\n   * } catch (e: any) {\n   *   console.error(\"Could not find document\");\n   * }\n   * ```\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const document = await collection.document(\"abc123\", { graceful: true });\n   * if (document) {\n   *   console.log(document);\n   * } else {\n   *   console.error(\"Could not find document\");\n   * }\n   * ```\n   */\n  document(\n    selector: documents.DocumentSelector,\n    options?: documents.ReadDocumentOptions\n  ): Promise<documents.Document<EntryResultType>>;\n  /**\n   * Retrieves the document matching the given key or id.\n   *\n   * Throws an exception when passed a document or `_id` from a different\n   * collection.\n   *\n   * @param selector - Document `_key`, `_id` or object with either of those\n   * properties (e.g. a document from this collection).\n   * @param graceful - If set to `true`, `null` is returned instead of an\n   * exception being thrown if the document does not exist.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * try {\n   *   const document = await collection.document(\"abc123\", false);\n   *   console.log(document);\n   * } catch (e: any) {\n   *   console.error(\"Could not find document\");\n   * }\n   * ```\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const document = await collection.document(\"abc123\", true);\n   * if (document) {\n   *   console.log(document);\n   * } else {\n   *   console.error(\"Could not find document\");\n   * }\n   * ```\n   */\n  document(\n    selector: documents.DocumentSelector,\n    graceful: boolean\n  ): Promise<documents.Document<EntryResultType>>;\n  /**\n   * Retrieves the documents matching the given key or id values.\n   *\n   * Throws an exception when passed a document or `_id` from a different\n   * collection, or if the document does not exist.\n   *\n   * @param selectors - Array of document `_key`, `_id` or objects with either\n   * of those properties (e.g. a document from this collection).\n   * @param options - Options for retrieving the documents.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * try {\n   *   const documents = await collection.documents([\"abc123\", \"xyz456\"]);\n   *   console.log(documents);\n   * } catch (e: any) {\n   *   console.error(\"Could not find document\");\n   * }\n   * ```\n   */\n  documents(\n    selectors: (string | documents.ObjectWithDocumentKey)[],\n    options?: documents.BulkReadDocumentsOptions\n  ): Promise<documents.Document<EntryResultType>[]>;\n  /**\n   * Inserts a new document with the given `data` into the collection.\n   *\n   * @param data - The contents of the new document.\n   * @param options - Options for inserting the document.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const result = await collection.save(\n   *   { _key: \"a\", color: \"blue\", count: 1 },\n   *   { returnNew: true }\n   * );\n   * console.log(result.new.color, result.new.count); // \"blue\" 1\n   * ```\n   */\n  save(\n    data: documents.DocumentData<EntryInputType>,\n    options?: documents.InsertDocumentOptions\n  ): Promise<\n    documents.DocumentOperationMetadata & {\n      new?: documents.Document<EntryResultType>;\n      old?: documents.Document<EntryResultType>;\n    }\n  >;\n  /**\n   * Inserts new documents with the given `data` into the collection.\n   *\n   * @param data - The contents of the new documents.\n   * @param options - Options for inserting the documents.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const result = await collection.saveAll(\n   *   [\n   *     { _key: \"a\", color: \"blue\", count: 1 },\n   *     { _key: \"b\", color: \"red\", count: 2 },\n   *   ],\n   *   { returnNew: true }\n   * );\n   * console.log(result[0].new.color, result[0].new.count); // \"blue\" 1\n   * console.log(result[1].new.color, result[1].new.count); // \"red\" 2\n   * ```\n   */\n  saveAll(\n    data: Array<documents.DocumentData<EntryInputType>>,\n    options?: documents.InsertDocumentOptions\n  ): Promise<\n    Array<\n      | (documents.DocumentOperationMetadata & {\n          new?: documents.Document<EntryResultType>;\n          old?: documents.Document<EntryResultType>;\n        })\n      | documents.DocumentOperationFailure\n    >\n  >;\n  /**\n   * Replaces an existing document in the collection.\n   *\n   * Throws an exception when passed a document or `_id` from a different\n   * collection.\n   *\n   * @param selector - Document `_key`, `_id` or object with either of those\n   * properties (e.g. a document from this collection).\n   * @param newData - The contents of the new document.\n   * @param options - Options for replacing the document.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.save({ _key: \"a\", color: \"blue\", count: 1 });\n   * const result = await collection.replace(\n   *   \"a\",\n   *   { color: \"red\" },\n   *   { returnNew: true }\n   * );\n   * console.log(result.new.color, result.new.count); // \"red\" undefined\n   * ```\n   */\n  replace(\n    selector: documents.DocumentSelector,\n    newData: documents.DocumentData<EntryInputType>,\n    options?: documents.ReplaceDocumentOptions\n  ): Promise<\n    documents.DocumentOperationMetadata & {\n      new?: documents.Document<EntryResultType>;\n      old?: documents.Document<EntryResultType>;\n    }\n  >;\n  /**\n   * Replaces existing documents in the collection, identified by the `_key` or\n   * `_id` of each document.\n   *\n   * @param newData - The documents to replace.\n   * @param options - Options for replacing the documents.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.save({ _key: \"a\", color: \"blue\", count: 1 });\n   * await collection.save({ _key: \"b\", color: \"green\", count: 3 });\n   * const result = await collection.replaceAll(\n   *   [\n   *     { _key: \"a\", color: \"red\" },\n   *     { _key: \"b\", color: \"yellow\", count: 2 }\n   *   ],\n   *   { returnNew: true }\n   * );\n   * console.log(result[0].new.color, result[0].new.count); // \"red\" undefined\n   * console.log(result[1].new.color, result[1].new.count); // \"yellow\" 2\n   * ```\n   */\n  replaceAll(\n    newData: Array<\n      documents.DocumentData<EntryInputType> &\n        ({ _key: string } | { _id: string })\n    >,\n    options?: Omit<documents.ReplaceDocumentOptions, \"ifMatch\">\n  ): Promise<\n    Array<\n      | (documents.DocumentOperationMetadata & {\n          new?: documents.Document<EntryResultType>;\n          old?: documents.Document<EntryResultType>;\n        })\n      | documents.DocumentOperationFailure\n    >\n  >;\n  /**\n   * Updates an existing document in the collection.\n   *\n   * Throws an exception when passed a document or `_id` from a different\n   * collection.\n   *\n   * @param selector - Document `_key`, `_id` or object with either of those\n   * properties (e.g. a document from this collection).\n   * @param newData - The data for updating the document.\n   * @param options - Options for updating the document.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.save({ _key: \"a\", color: \"blue\", count: 1 });\n   * const result = await collection.update(\n   *   \"a\",\n   *   { count: 2 },\n   *   { returnNew: true }\n   * );\n   * console.log(result.new.color, result.new.count); // \"blue\" 2\n   * ```\n   */\n  update(\n    selector: documents.DocumentSelector,\n    newData: documents.Patch<documents.DocumentData<EntryInputType>>,\n    options?: documents.UpdateDocumentOptions\n  ): Promise<\n    documents.DocumentOperationMetadata & {\n      new?: documents.Document<EntryResultType>;\n      old?: documents.Document<EntryResultType>;\n    }\n  >;\n  /**\n   * Updates existing documents in the collection, identified by the `_key` or\n   * `_id` of each document.\n   *\n   * @param newData - The data for updating the documents.\n   * @param options - Options for updating the documents.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.save({ _key: \"a\", color: \"blue\", count: 1 });\n   * await collection.save({ _key: \"b\", color: \"green\", count: 3 });\n   * const result = await collection.updateAll(\n   *   [\n   *     { _key: \"a\", count: 2 },\n   *     { _key: \"b\", count: 4 }\n   *   ],\n   *   { returnNew: true }\n   * );\n   * console.log(result[0].new.color, result[0].new.count); // \"blue\" 2\n   * console.log(result[1].new.color, result[1].new.count); // \"green\" 4\n   * ```\n   */\n  updateAll(\n    newData: Array<\n      documents.Patch<documents.DocumentData<EntryInputType>> &\n        ({ _key: string } | { _id: string })\n    >,\n    options?: Omit<documents.UpdateDocumentOptions, \"ifMatch\">\n  ): Promise<\n    Array<\n      | (documents.DocumentOperationMetadata & {\n          new?: documents.Document<EntryResultType>;\n          old?: documents.Document<EntryResultType>;\n        })\n      | documents.DocumentOperationFailure\n    >\n  >;\n  /**\n   * Removes an existing document from the collection.\n   *\n   * Throws an exception when passed a document or `_id` from a different\n   * collection.\n   *\n   * @param selector - Document `_key`, `_id` or object with either of those\n   * properties (e.g. a document from this collection).\n   * @param options - Options for removing the document.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.remove(\"abc123\");\n   * // document with key \"abc123\" deleted\n   * ```\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const doc = await collection.document(\"abc123\");\n   * await collection.remove(doc);\n   * // document with key \"abc123\" deleted\n   * ```\n   */\n  remove(\n    selector: documents.DocumentSelector,\n    options?: documents.RemoveDocumentOptions\n  ): Promise<\n    documents.DocumentMetadata & { old?: documents.Document<EntryResultType> }\n  >;\n  /**\n   * Removes existing documents from the collection.\n   *\n   * Throws an exception when passed any document or `_id` from a different\n   * collection.\n   *\n   * @param selectors - Documents `_key`, `_id` or objects with either of those\n   * properties (e.g. documents from this collection).\n   * @param options - Options for removing the documents.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.removeAll([\"abc123\", \"def456\"]);\n   * // document with keys \"abc123\" and \"def456\" deleted\n   * ```\n   */\n  removeAll(\n    selectors: (string | documents.ObjectWithDocumentKey)[],\n    options?: Omit<documents.RemoveDocumentOptions, \"ifMatch\">\n  ): Promise<\n    Array<\n      | (documents.DocumentMetadata & {\n          old?: documents.Document<EntryResultType>;\n        })\n      | documents.DocumentOperationFailure\n    >\n  >;\n  /**\n   * Bulk imports the given `data` into the collection.\n   *\n   * @param data - The data to import, as an array of document data.\n   * @param options - Options for importing the data.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.import(\n   *   [\n   *     { _key: \"jcd\", password: \"bionicman\" },\n   *     { _key: \"jreyes\", password: \"amigo\" },\n   *     { _key: \"ghermann\", password: \"zeitgeist\" }\n   *   ]\n   * );\n   * ```\n   */\n  import(\n    data: documents.DocumentData<EntryInputType>[],\n    options?: documents.ImportDocumentsOptions\n  ): Promise<documents.ImportDocumentsResult>;\n  /**\n   * Bulk imports the given `data` into the collection.\n   *\n   * @param data - The data to import, as an array containing a single array of\n   * attribute names followed by one or more arrays of attribute values for\n   * each document.\n   * @param options - Options for importing the data.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.import(\n   *   [\n   *     [ \"_key\", \"password\" ],\n   *     [ \"jcd\", \"bionicman\" ],\n   *     [ \"jreyes\", \"amigo\" ],\n   *     [ \"ghermann\", \"zeitgeist\" ]\n   *   ]\n   * );\n   * ```\n   */\n  import(\n    data: any[][],\n    options?: documents.ImportDocumentsOptions\n  ): Promise<documents.ImportDocumentsResult>;\n  /**\n   * Bulk imports the given `data` into the collection.\n   *\n   * If `type` is omitted, `data` must contain one JSON array per line with\n   * the first array providing the attribute names and all other arrays\n   * providing attribute values for each document.\n   *\n   * If `type` is set to `\"documents\"`, `data` must contain one JSON document\n   * per line.\n   *\n   * If `type` is set to `\"list\"`, `data` must contain a JSON array of\n   * documents.\n   *\n   * If `type` is set to `\"auto\"`, `data` can be in either of the formats\n   * supported by `\"documents\"` or `\"list\"`.\n   *\n   * @param data - The data to import as a Buffer (Node), Blob (browser) or\n   * string.\n   * @param options - Options for importing the data.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.import(\n   *   '{\"_key\":\"jcd\",\"password\":\"bionicman\"}\\r\\n' +\n   *   '{\"_key\":\"jreyes\",\"password\":\"amigo\"}\\r\\n' +\n   *   '{\"_key\":\"ghermann\",\"password\":\"zeitgeist\"}\\r\\n',\n   *   { type: \"documents\" } // or \"auto\"\n   * );\n   * ```\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.import(\n   *   '[{\"_key\":\"jcd\",\"password\":\"bionicman\"},' +\n   *   '{\"_key\":\"jreyes\",\"password\":\"amigo\"},' +\n   *   '{\"_key\":\"ghermann\",\"password\":\"zeitgeist\"}]',\n   *   { type: \"list\" } // or \"auto\"\n   * );\n   * ```\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.import(\n   *   '[\"_key\",\"password\"]\\r\\n' +\n   *   '[\"jcd\",\"bionicman\"]\\r\\n' +\n   *   '[\"jreyes\",\"amigo\"]\\r\\n' +\n   *   '[\"ghermann\",\"zeitgeist\"]\\r\\n'\n   * );\n   * ```\n   */\n  import(\n    data: Buffer | Blob | string,\n    options?: documents.ImportDocumentsOptions & {\n      type?: \"documents\" | \"list\" | \"auto\";\n    }\n  ): Promise<documents.ImportDocumentsResult>;\n  //#endregion\n\n  //#region Index operations\n  /**\n   * Instructs ArangoDB to load as many indexes of the collection into memory\n   * as permitted by the memory limit.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"indexed-collection\");\n   * await collection.loadIndexes();\n   * // the indexes are now loaded into memory\n   * ```\n   */\n  loadIndexes(): Promise<boolean>;\n  /**\n   * Returns a list of all index descriptions for the collection.\n   *\n   * @param options - Options for fetching the index list.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const indexes = await collection.indexes();\n   * ```\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const allIndexes = await collection.indexes<HiddenIndexDescription>({\n   *   withHidden: true\n   * });\n   * ```\n   */\n  indexes<\n    IndexType extends\n      | indexes.IndexDescription\n      | indexes.HiddenIndexDescription = indexes.IndexDescription,\n  >(\n    options?: indexes.ListIndexesOptions\n  ): Promise<IndexType[]>;\n  /**\n   * Returns an index description by name or `id` if it exists.\n   *\n   * @param selector - Index name, id or object with either property.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const index = await collection.index(\"some-index\");\n   * ```\n   */\n  index(selector: indexes.IndexSelector): Promise<indexes.IndexDescription>;\n  /**\n   * Creates a persistent index on the collection if it does not already exist.\n   *\n   * @param options - Options for creating the persistent index.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * // Create a unique index for looking up documents by username\n   * await collection.ensureIndex({\n   *   type: \"persistent\",\n   *   fields: [\"username\"],\n   *   name: \"unique-usernames\",\n   *   unique: true\n   * });\n   * ```\n   */\n  ensureIndex(\n    options: indexes.EnsurePersistentIndexOptions\n  ): Promise<\n    connection.ArangoApiResponse<\n      indexes.PersistentIndexDescription & { isNewlyCreated: boolean }\n    >\n  >;\n  /**\n   * Creates a TTL index on the collection if it does not already exist.\n   *\n   * @param options - Options for creating the TTL index.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * // Expire documents with \"createdAt\" timestamp one day after creation\n   * await collection.ensureIndex({\n   *   type: \"ttl\",\n   *   fields: [\"createdAt\"],\n   *   expireAfter: 60 * 60 * 24 // 24 hours\n   * });\n   * ```\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * // Expire documents with \"expiresAt\" timestamp according to their value\n   * await collection.ensureIndex({\n   *   type: \"ttl\",\n   *   fields: [\"expiresAt\"],\n   *   expireAfter: 0 // when attribute value is exceeded\n   * });\n   * ```\n   */\n  ensureIndex(\n    options: indexes.EnsureTtlIndexOptions\n  ): Promise<\n    connection.ArangoApiResponse<\n      indexes.TtlIndexDescription & { isNewlyCreated: boolean }\n    >\n  >;\n  /**\n   * Creates a multi-dimensional index on the collection if it does not already exist.\n   *\n   * @param options - Options for creating the multi-dimensional index.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-points\");\n   * // Create a multi-dimensional index for the attributes x, y and z\n   * await collection.ensureIndex({\n   *   type: \"mdi\",\n   *   fields: [\"x\", \"y\", \"z\"],\n   *   fieldValueTypes: \"double\"\n   * });\n   * ```\n   * ```\n   */\n  ensureIndex(\n    options: indexes.EnsureMdiIndexOptions\n  ): Promise<\n    connection.ArangoApiResponse<\n      indexes.MdiIndexDescription & { isNewlyCreated: boolean }\n    >\n  >;\n  /**\n   * Creates a prefixed multi-dimensional index on the collection if it does\n   * not already exist.\n   *\n   * @param options - Options for creating the prefixed multi-dimensional index.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-points\");\n   * // Create a multi-dimensional index for the attributes x, y and z\n   * await collection.ensureIndex({\n   *   type: \"mdi-prefixed\",\n   *   fields: [\"x\", \"y\", \"z\"],\n   *   prefixFields: [\"x\"],\n   *   fieldValueTypes: \"double\"\n   * });\n   * ```\n   * ```\n   */\n  ensureIndex(\n    options: indexes.EnsureMdiPrefixedIndexOptions\n  ): Promise<\n    connection.ArangoApiResponse<\n      indexes.MdiPrefixedIndexDescription & { isNewlyCreated: boolean }\n    >\n  >;\n  /**\n   * Creates a prefixed multi-dimensional index on the collection if it does not already exist.\n   *\n   * @param details - Options for creating the prefixed multi-dimensional index.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-points\");\n   * // Create a multi-dimensional index for the attributes x, y and z\n   * await collection.ensureIndex({\n   *   type: \"mdi-prefixed\",\n   *   fields: [\"x\", \"y\", \"z\"],\n   *   prefixFields: [\"x\"],\n   *   fieldValueTypes: \"double\"\n   * });\n   * ```\n   * ```\n   */\n  ensureIndex(\n    details: indexes.EnsureMdiPrefixedIndexOptions\n  ): Promise<\n    connection.ArangoApiResponse<\n      indexes.MdiPrefixedIndexDescription & { isNewlyCreated: boolean }\n    >\n  >;\n  /**\n   * Creates a geo index on the collection if it does not already exist.\n   *\n   * @param options - Options for creating the geo index.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * // Create an index for GeoJSON data\n   * await collection.ensureIndex({\n   *   type: \"geo\",\n   *   fields: [\"lngLat\"],\n   *   geoJson: true\n   * });\n   * ```\n   */\n  ensureIndex(\n    options: indexes.EnsureGeoIndexOptions\n  ): Promise<\n    connection.ArangoApiResponse<\n      indexes.GeoIndexDescription & { isNewlyCreated: boolean }\n    >\n  >;\n  /**\n   * Creates a inverted index on the collection if it does not already exist.\n   *\n   * @param options - Options for creating the inverted index.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * // Create an inverted index\n   * await collection.ensureIndex({\n   *   type: \"inverted\",\n   *   fields: [\"a\", { name: \"b\", analyzer: \"text_en\" }]\n   * });\n   * ```\n   */\n  ensureIndex(\n    options: indexes.EnsureInvertedIndexOptions\n  ): Promise<\n    connection.ArangoApiResponse<\n      indexes.InvertedIndexDescription & { isNewlyCreated: boolean }\n    >\n  >;\n  /**\n   * Creates an index on the collection if it does not already exist.\n   *\n   * @param options - Options for creating the index.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * // Create a unique index for looking up documents by username\n   * await collection.ensureIndex({\n   *   type: \"persistent\",\n   *   fields: [\"username\"],\n   *   name: \"unique-usernames\",\n   *   unique: true\n   * });\n   * ```\n   */\n  ensureIndex(\n    options: indexes.EnsureIndexOptions\n  ): Promise<\n    connection.ArangoApiResponse<\n      indexes.IndexDescription & { isNewlyCreated: boolean }\n    >\n  >;\n  /**\n   * Deletes the index with the given name or `id` from the database.\n   *\n   * @param selector - Index name, id or object with either property.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.dropIndex(\"some-index\");\n   * // The index \"some-index\" no longer exists\n   * ```\n   */\n  dropIndex(\n    selector: indexes.IndexSelector\n  ): Promise<connection.ArangoApiResponse<{ id: string }>>;\n  //#endregion\n}\n//#endregion\n\n//#region EdgeCollection interface\n/**\n * Represents an edge collection in a {@link databases.Database}.\n *\n * See {@link DocumentCollection} for a more generic variant of this interface\n * more suited for regular document collections.\n *\n * See also {@link graphs.GraphEdgeCollection} for the type representing an edge\n * collection in a {@link graphs.Graph}.\n *\n * When using TypeScript, collections can be cast to a specific edge document\n * data type to increase type safety.\n *\n * @param EntryResultType - Type to represent edge document contents returned\n * by the server (including computed properties).\n * @param EntryInputType - Type to represent edge document contents passed when\n * inserting or replacing edge documents (without computed properties).\n *\n * @example\n * ```ts\n * interface Friend {\n *   startDate: number;\n *   endDate?: number;\n * }\n * const db = new Database();\n * const edges = db.collection(\"friends\") as EdgeCollection<Friend>;\n * ```\n */\nexport interface EdgeCollection<\n  EntryResultType extends Record<string, any> = any,\n  EntryInputType extends Record<string, any> = EntryResultType,\n> extends DocumentCollection<EntryResultType, EntryInputType> {\n  //#region Document operations\n  /**\n   * Retrieves the document matching the given key or id.\n   *\n   * Throws an exception when passed a document or `_id` from a different\n   * collection, or if the document does not exist.\n   *\n   * @param selector - Document `_key`, `_id` or object with either of those\n   * properties (e.g. a document from this collection).\n   * @param options - Options for retrieving the document.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * try {\n   *   const document = await collection.document(\"abc123\");\n   *   console.log(document);\n   * } catch (e: any) {\n   *   console.error(\"Could not find document\");\n   * }\n   * ```\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const document = await collection.document(\"abc123\", { graceful: true });\n   * if (document) {\n   *   console.log(document);\n   * } else {\n   *   console.error(\"Document does not exist\");\n   * }\n   * ```\n   */\n  document(\n    selector: documents.DocumentSelector,\n    options?: documents.ReadDocumentOptions\n  ): Promise<documents.Edge<EntryResultType>>;\n  /**\n   * Retrieves the document matching the given key or id.\n   *\n   * Throws an exception when passed a document or `_id` from a different\n   * collection, or if the document does not exist.\n   *\n   * @param selector - Document `_key`, `_id` or object with either of those\n   * properties (e.g. a document from this collection).\n   * @param graceful - If set to `true`, `null` is returned instead of an\n   * exception being thrown if the document does not exist.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * try {\n   *   const document = await collection.document(\"abc123\", false);\n   *   console.log(document);\n   * } catch (e: any) {\n   *   console.error(\"Could not find document\");\n   * }\n   * ```\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * const document = await collection.document(\"abc123\", true);\n   * if (document) {\n   *   console.log(document);\n   * } else {\n   *   console.error(\"Document does not exist\");\n   * }\n   * ```\n   */\n  document(\n    selector: documents.DocumentSelector,\n    graceful: boolean\n  ): Promise<documents.Edge<EntryResultType>>;\n  /**\n   * Retrieves the documents matching the given key or id values.\n   *\n   * Throws an exception when passed a document or `_id` from a different\n   * collection, or if the document does not exist.\n   *\n   * @param selectors - Array of document `_key`, `_id` or objects with either\n   * of those properties (e.g. a document from this collection).\n   * @param options - Options for retrieving the documents.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * try {\n   *   const documents = await collection.documents([\"abc123\", \"xyz456\"]);\n   *   console.log(documents);\n   * } catch (e: any) {\n   *   console.error(\"Could not find document\");\n   * }\n   * ```\n   */\n  documents(\n    selectors: (string | documents.ObjectWithDocumentKey)[],\n    options?: documents.BulkReadDocumentsOptions\n  ): Promise<documents.Edge<EntryResultType>[]>;\n  /**\n   * Inserts a new document with the given `data` into the collection.\n   *\n   * @param data - The contents of the new document.\n   * @param options - Options for inserting the document.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"friends\");\n   * const result = await collection.save(\n   *   { _from: \"users/rana\", _to: \"users/mudasir\", active: false },\n   *   { returnNew: true }\n   * );\n   * ```\n   */\n  save(\n    data: documents.EdgeData<EntryInputType>,\n    options?: documents.InsertDocumentOptions\n  ): Promise<\n    documents.DocumentOperationMetadata & {\n      new?: documents.Edge<EntryResultType>;\n      old?: documents.Edge<EntryResultType>;\n    }\n  >;\n  /**\n   * Inserts new documents with the given `data` into the collection.\n   *\n   * @param data - The contents of the new documents.\n   * @param options - Options for inserting the documents.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"friends\");\n   * const result = await collection.saveAll(\n   *   [\n   *     { _from: \"users/rana\", _to: \"users/mudasir\", active: false },\n   *     { _from: \"users/rana\", _to: \"users/salman\", active: true }\n   *   ],\n   *   { returnNew: true }\n   * );\n   * ```\n   */\n  saveAll(\n    data: Array<documents.EdgeData<EntryInputType>>,\n    options?: documents.InsertDocumentOptions\n  ): Promise<\n    Array<\n      | (documents.DocumentOperationMetadata & {\n          new?: documents.Edge<EntryResultType>;\n          old?: documents.Edge<EntryResultType>;\n        })\n      | documents.DocumentOperationFailure\n    >\n  >;\n  /**\n   * Replaces an existing document in the collection.\n   *\n   * Throws an exception when passed a document or `_id` from a different\n   * collection.\n   *\n   * @param selector - Document `_key`, `_id` or object with either of those\n   * properties (e.g. a document from this collection).\n   * @param newData - The contents of the new document.\n   * @param options - Options for replacing the document.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"friends\");\n   * await collection.save(\n   *   {\n   *     _key: \"musadir\",\n   *     _from: \"users/rana\",\n   *     _to: \"users/mudasir\",\n   *     active: true,\n   *     best: true\n   *   }\n   * );\n   * const result = await collection.replace(\n   *   \"musadir\",\n   *   { active: false },\n   *   { returnNew: true }\n   * );\n   * console.log(result.new.active, result.new.best); // false undefined\n   * ```\n   */\n  replace(\n    selector: documents.DocumentSelector,\n    newData: documents.DocumentData<EntryInputType>,\n    options?: documents.ReplaceDocumentOptions\n  ): Promise<\n    documents.DocumentOperationMetadata & {\n      new?: documents.Edge<EntryResultType>;\n      old?: documents.Edge<EntryResultType>;\n    }\n  >;\n  /**\n   * Replaces existing documents in the collection, identified by the `_key` or\n   * `_id` of each document.\n   *\n   * @param newData - The documents to replace.\n   * @param options - Options for replacing the documents.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"friends\");\n   * await collection.save(\n   *   {\n   *     _key: \"musadir\",\n   *     _from: \"users/rana\",\n   *     _to: \"users/mudasir\",\n   *     active: true,\n   *     best: true\n   *   }\n   * );\n   * await collection.save(\n   *   {\n   *     _key: \"salman\",\n   *     _from: \"users/rana\",\n   *     _to: \"users/salman\",\n   *     active: false,\n   *     best: false\n   *   }\n   * );\n   * const result = await collection.replaceAll(\n   *   [\n   *     { _key: \"musadir\", active: false },\n   *     { _key: \"salman\", active: true, best: true }\n   *   ],\n   *   { returnNew: true }\n   * );\n   * console.log(result[0].new.active, result[0].new.best); // false undefined\n   * console.log(result[1].new.active, result[1].new.best); // true true\n   * ```\n   */\n  replaceAll(\n    newData: Array<\n      documents.DocumentData<EntryInputType> &\n        ({ _key: string } | { _id: string })\n    >,\n    options?: documents.ReplaceDocumentOptions\n  ): Promise<\n    Array<\n      | (documents.DocumentOperationMetadata & {\n          new?: documents.Edge<EntryResultType>;\n          old?: documents.Edge<EntryResultType>;\n        })\n      | documents.DocumentOperationFailure\n    >\n  >;\n  /**\n   * Updates an existing document in the collection.\n   *\n   * Throws an exception when passed a document or `_id` from a different\n   * collection.\n   *\n   * @param selector - Document `_key`, `_id` or object with either of those\n   * properties (e.g. a document from this collection).\n   * @param newData - The data for updating the document.\n   * @param options - Options for updating the document.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"friends\");\n   * await collection.save(\n   *   {\n   *     _key: \"musadir\",\n   *     _from: \"users/rana\",\n   *     _to: \"users/mudasir\",\n   *     active: true,\n   *     best: true\n   *   }\n   * );\n   * const result = await collection.update(\n   *   \"musadir\",\n   *   { active: false },\n   *   { returnNew: true }\n   * );\n   * console.log(result.new.active, result.new.best); // false true\n   * ```\n   */\n  update(\n    selector: documents.DocumentSelector,\n    newData: documents.Patch<documents.DocumentData<EntryInputType>>,\n    options?: documents.UpdateDocumentOptions\n  ): Promise<\n    documents.DocumentOperationMetadata & {\n      new?: documents.Edge<EntryResultType>;\n      old?: documents.Edge<EntryResultType>;\n    }\n  >;\n  /**\n   * Updates existing documents in the collection, identified by the `_key` or\n   * `_id` of each document.\n   *\n   * @param newData - The data for updating the documents.\n   * @param options - Options for updating the documents.\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"friends\");\n   * await collection.save(\n   *   {\n   *     _key: \"musadir\",\n   *     _from: \"users/rana\",\n   *     _to: \"users/mudasir\",\n   *     active: true,\n   *     best: true\n   *   }\n   * );\n   * await collection.save(\n   *   {\n   *     _key: \"salman\",\n   *     _from: \"users/rana\",\n   *     _to: \"users/salman\",\n   *     active: false,\n   *     best: false\n   *   }\n   * );\n   * const result = await collection.updateAll(\n   *   [\n   *     { _key: \"musadir\", active: false },\n   *     { _key: \"salman\", active: true, best: true }\n   *   ],\n   *   { returnNew: true }\n   * );\n   * console.log(result[0].new.active, result[0].new.best); // false true\n   * console.log(result[1].new.active, result[1].new.best); // true true\n   * ```\n   */\n  updateAll(\n    newData: Array<\n      documents.Patch<documents.DocumentData<EntryInputType>> &\n        ({ _key: string } | { _id: string })\n    >,\n    options?: documents.UpdateDocumentOptions\n  ): Promise<\n    Array<\n      | (documents.DocumentOperationMetadata & {\n          new?: documents.Edge<EntryResultType>;\n          old?: documents.Edge<EntryResultType>;\n        })\n      | documents.DocumentOperationFailure\n    >\n  >;\n  /**\n   * Removes an existing document from the collection.\n   *\n   * Throws an exception when passed a document or `_id` from a different\n   * collection.\n   *\n   * @param selector - Document `_key`, `_id` or object with either of those\n   * properties (e.g. a document from this collection).\n   * @param options - Options for removing the document.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"friends\");\n   * const doc = await collection.document(\"musadir\");\n   * await collection.remove(doc);\n   * // document with key \"musadir\" deleted\n   * ```\n   */\n  remove(\n    selector: documents.DocumentSelector,\n    options?: documents.RemoveDocumentOptions\n  ): Promise<\n    documents.DocumentMetadata & { old?: documents.Edge<EntryResultType> }\n  >;\n  /**\n   * Removes existing documents from the collection.\n   *\n   * Throws an exception when passed any document or `_id` from a different\n   * collection.\n   *\n   * @param selectors - Documents `_key`, `_id` or objects with either of those\n   * properties (e.g. documents from this collection).\n   * @param options - Options for removing the documents.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"friends\");\n   * await collection.removeAll([\"musadir\", \"salman\"]);\n   * // document with keys \"musadir\" and \"salman\" deleted\n   * ```\n   */\n  removeAll(\n    selectors: documents.DocumentSelector[],\n    options?: documents.RemoveDocumentOptions\n  ): Promise<\n    Array<\n      | (documents.DocumentMetadata & { old?: documents.Edge<EntryResultType> })\n      | documents.DocumentOperationFailure\n    >\n  >;\n  /**\n   * Bulk imports the given `data` into the collection.\n   *\n   * @param data - The data to import, as an array of edge data.\n   * @param options - Options for importing the data.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.import(\n   *   [\n   *     { _key: \"x\", _from: \"vertices/a\", _to: \"vertices/b\", weight: 1 },\n   *     { _key: \"y\", _from: \"vertices/a\", _to: \"vertices/c\", weight: 2 }\n   *   ]\n   * );\n   * ```\n   */\n  import(\n    data: documents.EdgeData<EntryInputType>[],\n    options?: documents.ImportDocumentsOptions\n  ): Promise<documents.ImportDocumentsResult>;\n  /**\n   * Bulk imports the given `data` into the collection.\n   *\n   * @param data - The data to import, as an array containing a single array of\n   * attribute names followed by one or more arrays of attribute values for\n   * each edge document.\n   * @param options - Options for importing the data.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.import(\n   *   [\n   *     [ \"_key\", \"_from\", \"_to\", \"weight\" ],\n   *     [ \"x\", \"vertices/a\", \"vertices/b\", 1 ],\n   *     [ \"y\", \"vertices/a\", \"vertices/c\", 2 ]\n   *   ]\n   * );\n   * ```\n   */\n  import(\n    data: any[][],\n    options?: documents.ImportDocumentsOptions\n  ): Promise<documents.ImportDocumentsResult>;\n  /**\n   * Bulk imports the given `data` into the collection.\n   *\n   * If `type` is omitted, `data` must contain one JSON array per line with\n   * the first array providing the attribute names and all other arrays\n   * providing attribute values for each edge document.\n   *\n   * If `type` is set to `\"documents\"`, `data` must contain one JSON document\n   * per line.\n   *\n   * If `type` is set to `\"list\"`, `data` must contain a JSON array of\n   * edge documents.\n   *\n   * If `type` is set to `\"auto\"`, `data` can be in either of the formats\n   * supported by `\"documents\"` or `\"list\"`.\n   *\n   * @param data - The data to import as a Buffer (Node), Blob (browser) or\n   * string.\n   * @param options - Options for importing the data.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.import(\n   *   '{\"_key\":\"x\",\"_from\":\"vertices/a\",\"_to\":\"vertices/b\",\"weight\":1}\\r\\n' +\n   *   '{\"_key\":\"y\",\"_from\":\"vertices/a\",\"_to\":\"vertices/c\",\"weight\":2}\\r\\n',\n   *   { type: \"documents\" } // or \"auto\"\n   * );\n   * ```\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.import(\n   *   '[{\"_key\":\"x\",\"_from\":\"vertices/a\",\"_to\":\"vertices/b\",\"weight\":1},' +\n   *   '{\"_key\":\"y\",\"_from\":\"vertices/a\",\"_to\":\"vertices/c\",\"weight\":2}]',\n   *   { type: \"list\" } // or \"auto\"\n   * );\n   * ```\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"some-collection\");\n   * await collection.import(\n   *   '[\"_key\",\"_from\",\"_to\",\"weight\"]\\r\\n' +\n   *   '[\"x\",\"vertices/a\",\"vertices/b\",1]\\r\\n' +\n   *   '[\"y\",\"vertices/a\",\"vertices/c\",2]\\r\\n'\n   * );\n   * ```\n   */\n  import(\n    data: Buffer | Blob | string,\n    options?: documents.ImportDocumentsOptions & {\n      type?: \"documents\" | \"list\" | \"auto\";\n    }\n  ): Promise<documents.ImportDocumentsResult>;\n  //#endregion\n\n  //#region Edge operations\n  /**\n   * Retrieves a list of all edges in this collection of the document matching\n   * the given `selector`.\n   *\n   * Throws an exception when passed a document or `_id` from a different\n   * collection.\n   *\n   * @param selector - Document `_key`, `_id` or object with either of those\n   * properties (e.g. a document from this collection).\n   * @param options - Options for retrieving the edges.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"edges\");\n   * await collection.import([\n   *   [\"_key\", \"_from\", \"_to\"],\n   *   [\"x\", \"vertices/a\", \"vertices/b\"],\n   *   [\"y\", \"vertices/a\", \"vertices/c\"],\n   *   [\"z\", \"vertices/d\", \"vertices/a\"],\n   * ]);\n   * const edges = await collection.edges(\"vertices/a\");\n   * console.log(edges.map((edge) => edge._key)); // [\"x\", \"y\", \"z\"]\n   * ```\n   */\n  edges(\n    selector: documents.DocumentSelector,\n    options?: documents.DocumentEdgesOptions\n  ): Promise<\n    connection.ArangoApiResponse<documents.DocumentEdgesResult<EntryResultType>>\n  >;\n  /**\n   * Retrieves a list of all incoming edges of the document matching the given\n   * `selector`.\n   *\n   * Throws an exception when passed a document or `_id` from a different\n   * collection.\n   *\n   * @param selector - Document `_key`, `_id` or object with either of those\n   * properties (e.g. a document from this collection).\n   * @param options - Options for retrieving the edges.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"edges\");\n   * await collection.import([\n   *   [\"_key\", \"_from\", \"_to\"],\n   *   [\"x\", \"vertices/a\", \"vertices/b\"],\n   *   [\"y\", \"vertices/a\", \"vertices/c\"],\n   *   [\"z\", \"vertices/d\", \"vertices/a\"],\n   * ]);\n   * const edges = await collection.inEdges(\"vertices/a\");\n   * console.log(edges.map((edge) => edge._key)); // [\"z\"]\n   * ```\n   */\n  inEdges(\n    selector: documents.DocumentSelector,\n    options?: documents.DocumentEdgesOptions\n  ): Promise<\n    connection.ArangoApiResponse<documents.DocumentEdgesResult<EntryResultType>>\n  >;\n  /**\n   * Retrieves a list of all outgoing edges of the document matching the given\n   * `selector`.\n   *\n   * Throws an exception when passed a document or `_id` from a different\n   * collection.\n   *\n   * @param selector - Document `_key`, `_id` or object with either of those\n   * properties (e.g. a document from this collection).\n   * @param options - Options for retrieving the edges.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const collection = db.collection(\"edges\");\n   * await collection.import([\n   *   [\"_key\", \"_from\", \"_to\"],\n   *   [\"x\", \"vertices/a\", \"vertices/b\"],\n   *   [\"y\", \"vertices/a\", \"vertices/c\"],\n   *   [\"z\", \"vertices/d\", \"vertices/a\"],\n   * ]);\n   * const edges = await collection.outEdges(\"vertices/a\");\n   * console.log(edges.map((edge) => edge._key)); // [\"x\", \"y\"]\n   * ```\n   */\n  outEdges(\n    selector: documents.DocumentSelector,\n    options?: documents.DocumentEdgesOptions\n  ): Promise<\n    connection.ArangoApiResponse<documents.DocumentEdgesResult<EntryResultType>>\n  >;\n  //#endregion\n}\n//#endregion\n\n//#region Collection class\n/**\n * @internal\n */\nexport class Collection<\n    EntryResultType extends Record<string, any> = any,\n    EntryInputType extends Record<string, any> = EntryResultType,\n  >\n  implements\n    EdgeCollection<EntryResultType, EntryInputType>,\n    DocumentCollection<EntryResultType, EntryInputType>\n{\n  protected _name: string;\n  protected _db: databases.Database;\n\n  /**\n   * @internal\n   */\n  constructor(db: databases.Database, name: string) {\n    this._name = name;\n    this._db = db;\n  }\n\n  get isArangoCollection(): true {\n    return true;\n  }\n\n  get database() {\n    return this._db;\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  //#region Collection operations\n  get() {\n    return this._db.request({\n      pathname: `/_api/collection/${encodeURIComponent(this._name)}`,\n    });\n  }\n\n  async exists() {\n    try {\n      await this.get();\n      return true;\n    } catch (err: any) {\n      if (errors.isArangoError(err) && err.errorNum === COLLECTION_NOT_FOUND) {\n        return false;\n      }\n      throw err;\n    }\n  }\n\n  create(\n    options: CreateCollectionOptions & {\n      type?: CollectionType;\n    } = {}\n  ) {\n    const {\n      waitForSyncReplication = undefined,\n      enforceReplicationFactor = undefined,\n      ...opts\n    } = options;\n    if (opts.computedValues) {\n      opts.computedValues = opts.computedValues.map((computedValue) => {\n        if (aql.isAqlLiteral(computedValue.expression)) {\n          return {\n            ...computedValue,\n            expression: computedValue.expression.toAQL(),\n          };\n        }\n        if (aql.isAqlQuery(computedValue.expression)) {\n          return {\n            ...computedValue,\n            expression: computedValue.expression.query,\n          };\n        }\n        return computedValue;\n      });\n    }\n    const search: Record<string, any> = {};\n    if (typeof waitForSyncReplication === \"boolean\") {\n      search.waitForSyncReplication = waitForSyncReplication ? 1 : 0;\n    }\n    if (typeof enforceReplicationFactor === \"boolean\") {\n      search.enforceReplicationFactor = enforceReplicationFactor ? 1 : 0;\n    }\n    return this._db.request({\n      method: \"POST\",\n      pathname: \"/_api/collection\",\n      search,\n      body: {\n        ...opts,\n        name: this._name,\n      },\n    });\n  }\n\n  properties(\n    properties?: CollectionPropertiesOptions\n  ): Promise<\n    connection.ArangoApiResponse<CollectionDescription & CollectionProperties>\n  > {\n    if (!properties) {\n      return this._db.request({\n        pathname: `/_api/collection/${encodeURIComponent(this._name)}/properties`,\n      });\n    }\n    return this._db.request({\n      method: \"PUT\",\n      pathname: `/_api/collection/${encodeURIComponent(this._name)}/properties`,\n      body: properties,\n    });\n  }\n\n  count(): Promise<\n    connection.ArangoApiResponse<\n      CollectionDescription & CollectionProperties & { count: number }\n    >\n  > {\n    return this._db.request({\n      pathname: `/_api/collection/${encodeURIComponent(this._name)}/count`,\n    });\n  }\n\n  async recalculateCount(): Promise<boolean> {\n    return this._db.request(\n      {\n        method: \"PUT\",\n        pathname: `/_api/collection/${encodeURIComponent(\n          this._name\n        )}/recalculateCount`,\n      },\n      (res) => res.parsedBody.result\n    );\n  }\n\n  figures(\n    details = false\n  ): Promise<\n    connection.ArangoApiResponse<\n      CollectionDescription &\n        CollectionProperties & { count: number; figures: Record<string, any> }\n    >\n  > {\n    return this._db.request({\n      pathname: `/_api/collection/${encodeURIComponent(this._name)}/figures`,\n      search: { details },\n    });\n  }\n\n  revision(): Promise<\n    connection.ArangoApiResponse<\n      CollectionDescription & CollectionProperties & { revision: string }\n    >\n  > {\n    return this._db.request({\n      pathname: `/_api/collection/${encodeURIComponent(this._name)}/revision`,\n    });\n  }\n\n  checksum(\n    options?: CollectionChecksumOptions\n  ): Promise<\n    connection.ArangoApiResponse<\n      CollectionDescription & { revision: string; checksum: string }\n    >\n  > {\n    return this._db.request({\n      pathname: `/_api/collection/${encodeURIComponent(this._name)}/checksum`,\n      search: options,\n    });\n  }\n\n  shards(\n    details?: boolean\n  ): Promise<\n    connection.ArangoApiResponse<\n      CollectionDescription & CollectionProperties & { shards: any }\n    >\n  > {\n    return this._db.request({\n      pathname: `/_api/collection/${encodeURIComponent(this._name)}/shards`,\n      search: { details },\n    });\n  }\n\n  async rename(newName: string) {\n    const result = await this._db.renameCollection(this._name, newName);\n    this._name = newName;\n    return result;\n  }\n\n  truncate(\n    options?: TruncateCollectionOptions\n  ): Promise<connection.ArangoApiResponse<CollectionDescription>> {\n    return this._db.request({\n      method: \"PUT\",\n      pathname: `/_api/collection/${this._name}/truncate`,\n      search: options,\n    });\n  }\n\n  drop(options?: DropCollectionOptions) {\n    return this._db.request({\n      method: \"DELETE\",\n      pathname: `/_api/collection/${encodeURIComponent(this._name)}`,\n      search: options,\n    });\n  }\n\n  compact() {\n    return this._db.request({\n      method: \"PUT\",\n      pathname: `/_api/collection/${this._name}/compact`,\n    });\n  }\n  //#endregion\n\n  //#region Document operations\n  getResponsibleShard(\n    document: Partial<documents.Document<EntryResultType>>\n  ): Promise<string> {\n    return this._db.request(\n      {\n        method: \"PUT\",\n        pathname: `/_api/collection/${encodeURIComponent(\n          this._name\n        )}/responsibleShard`,\n        body: document,\n      },\n      (res) => res.parsedBody.shardId\n    );\n  }\n\n  documentId(selector: documents.DocumentSelector): string {\n    return documents._documentHandle(selector, this._name);\n  }\n\n  async documentExists(\n    selector: documents.DocumentSelector,\n    options: documents.DocumentExistsOptions = {}\n  ): Promise<boolean> {\n    const { ifMatch = undefined, ifNoneMatch = undefined } = options;\n    const headers = {} as Record<string, string>;\n    if (ifMatch) headers[\"if-match\"] = ifMatch;\n    if (ifNoneMatch) headers[\"if-none-match\"] = ifNoneMatch;\n    try {\n      return await this._db.request(\n        {\n          method: \"HEAD\",\n          pathname: `/_api/document/${encodeURI(\n            documents._documentHandle(selector, this._name)\n          )}`,\n          headers,\n        },\n        (res) => {\n          if (ifNoneMatch && res.status === 304) {\n            throw new errors.HttpError(res);\n          }\n          return true;\n        }\n      );\n    } catch (err: any) {\n      if (err.code === 404) {\n        return false;\n      }\n      throw err;\n    }\n  }\n\n  documents(\n    selectors: (string | documents.ObjectWithDocumentKey)[],\n    options: documents.BulkReadDocumentsOptions = {}\n  ) {\n    const { allowDirtyRead = undefined } = options;\n    return this._db.request({\n      method: \"PUT\",\n      pathname: `/_api/document/${encodeURIComponent(this._name)}`,\n      search: { onlyget: true },\n      allowDirtyRead,\n      body: selectors,\n    });\n  }\n\n  async document(\n    selector: documents.DocumentSelector,\n    options: boolean | documents.ReadDocumentOptions = {}\n  ) {\n    if (typeof options === \"boolean\") {\n      options = { graceful: options };\n    }\n    const {\n      allowDirtyRead = undefined,\n      graceful = false,\n      ifMatch = undefined,\n      ifNoneMatch = undefined,\n    } = options;\n    const headers = {} as Record<string, string>;\n    if (ifMatch) headers[\"if-match\"] = ifMatch;\n    if (ifNoneMatch) headers[\"if-none-match\"] = ifNoneMatch;\n    const result = this._db.request(\n      {\n        pathname: `/_api/document/${encodeURI(\n          documents._documentHandle(selector, this._name)\n        )}`,\n        headers,\n        allowDirtyRead,\n      },\n      (res) => {\n        if (ifNoneMatch && res.status === 304) {\n          throw new errors.HttpError(res);\n        }\n        return res.parsedBody;\n      }\n    );\n    if (!graceful) return result;\n    try {\n      return await result;\n    } catch (err: any) {\n      if (errors.isArangoError(err) && err.errorNum === DOCUMENT_NOT_FOUND) {\n        return null;\n      }\n      throw err;\n    }\n  }\n\n  save(\n    data: documents.DocumentData<EntryInputType>,\n    options?: documents.InsertDocumentOptions\n  ) {\n    return this._db.request(\n      {\n        method: \"POST\",\n        pathname: `/_api/document/${encodeURIComponent(this._name)}`,\n        body: data,\n        search: options,\n      },\n      (res) => (options?.silent ? undefined : res.parsedBody)\n    );\n  }\n\n  saveAll(\n    data: Array<documents.DocumentData<EntryInputType>>,\n    options?: documents.InsertDocumentOptions\n  ) {\n    return this._db.request(\n      {\n        method: \"POST\",\n        pathname: `/_api/document/${encodeURIComponent(this._name)}`,\n        body: data,\n        search: options,\n      },\n      (res) => (options?.silent ? undefined : res.parsedBody)\n    );\n  }\n\n  replace(\n    selector: documents.DocumentSelector,\n    newData: documents.DocumentData<EntryInputType>,\n    options: documents.ReplaceDocumentOptions = {}\n  ) {\n    const { ifMatch = undefined, ...opts } = options;\n    const headers = {} as Record<string, string>;\n    if (ifMatch) headers[\"if-match\"] = ifMatch;\n    return this._db.request(\n      {\n        method: \"PUT\",\n        pathname: `/_api/document/${encodeURI(\n          documents._documentHandle(selector, this._name)\n        )}`,\n        headers,\n        body: newData,\n        search: opts,\n      },\n      (res) => (options?.silent ? undefined : res.parsedBody)\n    );\n  }\n\n  replaceAll(\n    newData: Array<\n      documents.DocumentData<EntryInputType> &\n        ({ _key: string } | { _id: string })\n    >,\n    options?: documents.ReplaceDocumentOptions\n  ) {\n    return this._db.request(\n      {\n        method: \"PUT\",\n        pathname: `/_api/document/${encodeURIComponent(this._name)}`,\n        body: newData,\n        search: options,\n      },\n      (res) => (options?.silent ? undefined : res.parsedBody)\n    );\n  }\n\n  update(\n    selector: documents.DocumentSelector,\n    newData: documents.Patch<documents.DocumentData<EntryInputType>>,\n    options: documents.UpdateDocumentOptions = {}\n  ) {\n    const { ifMatch = undefined, ...opts } = options;\n    const headers = {} as Record<string, string>;\n    if (ifMatch) headers[\"if-match\"] = ifMatch;\n    return this._db.request(\n      {\n        method: \"PATCH\",\n        pathname: `/_api/document/${encodeURI(\n          documents._documentHandle(selector, this._name)\n        )}`,\n        headers,\n        body: newData,\n        search: opts,\n      },\n      (res) => (options?.silent ? undefined : res.parsedBody)\n    );\n  }\n\n  updateAll(\n    newData: Array<\n      documents.Patch<documents.DocumentData<EntryInputType>> &\n        ({ _key: string } | { _id: string })\n    >,\n    options?: documents.UpdateDocumentOptions\n  ) {\n    return this._db.request(\n      {\n        method: \"PATCH\",\n        pathname: `/_api/document/${encodeURIComponent(this._name)}`,\n        body: newData,\n        search: options,\n      },\n      (res) => (options?.silent ? undefined : res.parsedBody)\n    );\n  }\n\n  remove(\n    selector: documents.DocumentSelector,\n    options: documents.RemoveDocumentOptions = {}\n  ) {\n    const { ifMatch = undefined, ...opts } = options;\n    const headers = {} as Record<string, string>;\n    if (ifMatch) headers[\"if-match\"] = ifMatch;\n    return this._db.request(\n      {\n        method: \"DELETE\",\n        pathname: `/_api/document/${encodeURI(\n          documents._documentHandle(selector, this._name)\n        )}`,\n        headers,\n        search: opts,\n      },\n      (res) => (options?.silent ? undefined : res.parsedBody)\n    );\n  }\n\n  removeAll(\n    selectors: (string | documents.ObjectWithDocumentKey)[],\n    options?: documents.RemoveDocumentOptions\n  ) {\n    return this._db.request(\n      {\n        method: \"DELETE\",\n        pathname: `/_api/document/${encodeURIComponent(this._name)}`,\n        body: selectors,\n        search: options,\n      },\n      (res) => (options?.silent ? undefined : res.parsedBody)\n    );\n  }\n\n  import(\n    data: Buffer | Blob | string | any[],\n    options: documents.ImportDocumentsOptions & {\n      type?: \"documents\" | \"list\" | \"auto\";\n    } = {}\n  ): Promise<documents.ImportDocumentsResult> {\n    const search = { ...options, collection: this._name };\n    if (Array.isArray(data)) {\n      search.type = Array.isArray(data[0]) ? undefined : \"documents\";\n      const lines = data as any[];\n      data = lines.map((line) => JSON.stringify(line)).join(\"\\r\\n\") + \"\\r\\n\";\n    }\n    return this._db.request({\n      method: \"POST\",\n      pathname: \"/_api/import\",\n      body: data,\n      isBinary: true,\n      search,\n    });\n  }\n  //#endregion\n\n  //#region Edge operations\n  protected _edges(\n    selector: documents.DocumentSelector,\n    options: documents.DocumentEdgesOptions = {},\n    direction?: \"in\" | \"out\"\n  ) {\n    const { allowDirtyRead = undefined } = options;\n    return this._db.request({\n      pathname: `/_api/edges/${encodeURIComponent(this._name)}`,\n      allowDirtyRead,\n      search: {\n        direction,\n        vertex: documents._documentHandle(selector, this._name, false),\n      },\n    });\n  }\n\n  edges(\n    vertex: documents.DocumentSelector,\n    options?: documents.DocumentEdgesOptions\n  ) {\n    return this._edges(vertex, options);\n  }\n\n  inEdges(\n    vertex: documents.DocumentSelector,\n    options?: documents.DocumentEdgesOptions\n  ) {\n    return this._edges(vertex, options, \"in\");\n  }\n\n  outEdges(\n    vertex: documents.DocumentSelector,\n    options?: documents.DocumentEdgesOptions\n  ) {\n    return this._edges(vertex, options, \"out\");\n  }\n  //#endregion\n\n  //#region Index operations\n  async loadIndexes(): Promise<boolean> {\n    return this._db.request(\n      {\n        method: \"PUT\",\n        pathname: `/_api/collection/${encodeURIComponent(\n          this._name\n        )}/loadIndexesIntoMemory`,\n      },\n      (res) => res.parsedBody.result\n    );\n  }\n\n  indexes(options?: indexes.ListIndexesOptions) {\n    return this._db.request(\n      {\n        pathname: \"/_api/index\",\n        search: { collection: this._name, ...options },\n      },\n      (res) => res.parsedBody.indexes\n    );\n  }\n\n  index(selector: indexes.IndexSelector) {\n    return this._db.request({\n      pathname: `/_api/index/${encodeURI(indexes._indexHandle(selector, this._name))}`,\n    });\n  }\n\n  ensureIndex(options: indexes.EnsureIndexOptions) {\n    return this._db.request({\n      method: \"POST\",\n      pathname: \"/_api/index\",\n      body: options,\n      search: { collection: this._name },\n    });\n  }\n\n  dropIndex(selector: indexes.IndexSelector) {\n    return this._db.request({\n      method: \"DELETE\",\n      pathname: `/_api/index/${encodeURI(indexes._indexHandle(selector, this._name))}`,\n    });\n  }\n  //#endregion\n}\n//#endregion\n"]}