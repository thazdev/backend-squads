"use strict";
/**
 * Utility functions for arangojs.
 *
 * @packageDocumentation
 * @internal
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateStackTrace = exports.createTimer = exports.generateRequestId = exports.normalizeUrl = exports.mergeHeaders = exports.joinPath = void 0;
const THIRTY_MINUTES = 30 * 60_000;
/**
 * @internal
 *
 * Helper to merge path segments.
 */
function joinPath(...pathList) {
    if (!pathList.length)
        return "";
    return pathList
        .flatMap((path, i) => {
        if (!path)
            return [];
        if (i === pathList.length - 1) {
            if (i === 0)
                return [path];
            return [path.replace(/^\/+/, "")];
        }
        if (i === 0)
            return [path.replace(/\/+$/, "")];
        return [path.replace(/^\/+|\/+$/, "")];
    })
        .join("/");
}
exports.joinPath = joinPath;
/**
 * @internal
 *
 * Utility function for merging headers.
 */
function mergeHeaders(...headersList) {
    if (!headersList.length)
        return new Headers();
    return new Headers([
        ...headersList.flatMap((headers) => headers
            ? [
                ...(headers instanceof Headers || Array.isArray(headers)
                    ? headers
                    : new Headers(headers)),
            ]
            : []),
    ]);
}
exports.mergeHeaders = mergeHeaders;
/**
 * @internal
 *
 * Utility function for normalizing URLs.
 */
function normalizeUrl(url) {
    const raw = url.match(/^(tcp|ssl|tls)((?::|\+).+)/);
    if (raw)
        url = (raw[1] === "tcp" ? "http" : "https") + raw[2];
    const unix = url.match(/^(?:(http|https)\+)?unix:\/\/(\/.+)/);
    if (unix)
        url = `${unix[1] || "http"}://unix:${unix[2]}`;
    else if (!url.endsWith("/"))
        url += "/";
    return url;
}
exports.normalizeUrl = normalizeUrl;
/**
 * @internal
 *
 * Generate a unique request ID.
 */
function generateRequestId() {
    return `${Date.now() % THIRTY_MINUTES}_${Math.random().toString(36).substring(2, 15)}`;
}
exports.generateRequestId = generateRequestId;
/**
 * @internal
 *
 * Creates a timer that will call the given callback after the specified
 * timeout.
 *
 * @param timeout - Number of milliseconds after which the callback will be
 *   called.
 * @param callback - Callback to call after the timeout.
 * @returns A function that clears the timer.
 */
function createTimer(timeout, callback) {
    const t = setTimeout(callback, timeout);
    return () => clearTimeout(t);
}
exports.createTimer = createTimer;
/**
 * @internal
 *
 * Generates a stack trace.
 */
function generateStackTrace() {
    let err = new Error();
    if (!err.stack) {
        try {
            throw err;
        }
        catch (e) {
            err = e;
        }
    }
    return err;
}
exports.generateStackTrace = generateStackTrace;
//# sourceMappingURL=util.js.map