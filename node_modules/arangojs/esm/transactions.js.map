{"version":3,"file":"transactions.js","sourceRoot":"","sources":["../../src/transactions.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * ```ts\n * import type { Transaction } from \"arangojs/transactions\";\n * ```\n *\n * The \"transactions\" module provides transaction related types and interfaces\n * for TypeScript.\n *\n * @packageDocumentation\n */\nimport * as collections from \"./collections.js\";\nimport * as connection from \"./connection.js\";\nimport * as databases from \"./databases.js\";\nimport * as errors from \"./errors.js\";\nimport { TRANSACTION_NOT_FOUND } from \"./lib/codes.js\";\n\n//#region Transaction operation options\n/**\n * Collections involved in a transaction.\n */\nexport type TransactionCollectionOptions = {\n  /**\n   * An array of collections or a single collection that will be read from or\n   * written to during the transaction with no other writes being able to run\n   * in parallel.\n   */\n  exclusive?:\n    | (string | collections.ArangoCollection)[]\n    | string\n    | collections.ArangoCollection;\n  /**\n   * An array of collections or a single collection that will be read from or\n   * written to during the transaction.\n   */\n  write?:\n    | (string | collections.ArangoCollection)[]\n    | string\n    | collections.ArangoCollection;\n  /**\n   * An array of collections or a single collection that will be read from\n   * during the transaction.\n   */\n  read?:\n    | (string | collections.ArangoCollection)[]\n    | string\n    | collections.ArangoCollection;\n};\n\n/**\n * @internal\n */\nexport function coerceTransactionCollections(\n  options:\n    | (TransactionCollectionOptions & { allowImplicit?: boolean })\n    | (string | collections.ArangoCollection)[]\n    | string\n    | collections.ArangoCollection\n): CoercedTransactionCollections {\n  if (typeof options === \"string\") {\n    return { write: [options] };\n  }\n  if (Array.isArray(options)) {\n    return { write: options.map(collections.collectionToString) };\n  }\n  if (collections.isArangoCollection(options)) {\n    return { write: collections.collectionToString(options) };\n  }\n  const opts: CoercedTransactionCollections = {};\n  if (options) {\n    if (options.allowImplicit !== undefined) {\n      opts.allowImplicit = options.allowImplicit;\n    }\n    if (options.read) {\n      opts.read = Array.isArray(options.read)\n        ? options.read.map(collections.collectionToString)\n        : collections.collectionToString(options.read);\n    }\n    if (options.write) {\n      opts.write = Array.isArray(options.write)\n        ? options.write.map(collections.collectionToString)\n        : collections.collectionToString(options.write);\n    }\n    if (options.exclusive) {\n      opts.exclusive = Array.isArray(options.exclusive)\n        ? options.exclusive.map(collections.collectionToString)\n        : collections.collectionToString(options.exclusive);\n    }\n  }\n  return opts;\n}\n\n/**\n * @internal\n */\ntype CoercedTransactionCollections = {\n  allowImplicit?: boolean;\n  exclusive?: string | string[];\n  write?: string | string[];\n  read?: string | string[];\n};\n\n/**\n * Options for how the transaction should be performed.\n */\nexport type TransactionOptions = {\n  /**\n   * Whether the transaction may read from collections not specified for this\n   * transaction. If set to `false`, accessing any collections not specified\n   * will result in the transaction being aborted to avoid potential deadlocks.\n   *\n   * Default: `true`.\n   */\n  allowImplicit?: boolean;\n  /**\n   * If set to `true`, the request will explicitly permit ArangoDB to return a\n   * potentially dirty or stale result and arangojs will load balance the\n   * request without distinguishing between leaders and followers.\n   */\n  allowDirtyRead?: boolean;\n  /**\n   * Determines whether to force the transaction to write all data to disk\n   * before returning.\n   */\n  waitForSync?: boolean;\n  /**\n   * Determines how long the database will wait while attempting to gain locks\n   * on collections used by the transaction before timing out.\n   */\n  lockTimeout?: number;\n  /**\n   * Determines the transaction size limit in bytes.\n   */\n  maxTransactionSize?: number;\n  /**\n   * If set to `true`, the fast lock round will be skipped, which makes each\n   * locking operation take longer but guarantees deterministic locking order\n   * and may avoid deadlocks when many concurrent transactions are queued and\n   * try to access the same collection with an exclusive lock.\n   */\n  skipFastLockRound?: boolean;\n};\n\n/**\n * Options for how the transaction should be committed.\n */\nexport type TransactionCommitOptions = {\n  /**\n   * If set to `true`, the request will explicitly permit ArangoDB to return a\n   * potentially dirty or stale result and arangojs will load balance the\n   * request without distinguishing between leaders and followers.\n   */\n  allowDirtyRead?: boolean;\n};\n\n/**\n * Options for how the transaction should be aborted.\n */\nexport type TransactionAbortOptions = {\n  /**\n   * If set to `true`, the request will explicitly permit ArangoDB to return a\n   * potentially dirty or stale result and arangojs will load balance the\n   * request without distinguishing between leaders and followers.\n   */\n  allowDirtyRead?: boolean;\n};\n//#endregion\n\n//#region Transaction operation results\n/**\n * Description of a transaction in a list of transactions.\n *\n * See also {@link TransactionInfo}.\n */\nexport type TransactionDescription = {\n  /**\n   * Unique identifier of the transaction.\n   */\n  id: string;\n  /**\n   * Status (or \"state\") of the transaction.\n   */\n  state: \"running\" | \"committed\" | \"aborted\";\n};\n\n/**\n * Status of a given transaction.\n *\n * See also {@link TransactionDescription}.\n */\nexport type TransactionInfo = {\n  /**\n   * Unique identifier of the transaction.\n   */\n  id: string;\n  /**\n   * Status of the transaction.\n   */\n  status: \"running\" | \"committed\" | \"aborted\";\n};\n//#endregion\n//#region Transaction class\n/**\n * Indicates whether the given value represents a {@link Transaction}.\n *\n * @param transaction - A value that might be a transaction.\n */\nexport function isArangoTransaction(\n  transaction: any\n): transaction is Transaction {\n  return Boolean(transaction && transaction.isArangoTransaction);\n}\n\n/**\n * Represents a streaming transaction in a {@link databases.Database}.\n */\nexport class Transaction {\n  protected _db: databases.Database;\n  protected _id: string;\n\n  /**\n   * @internal\n   */\n  constructor(db: databases.Database, id: string) {\n    this._db = db;\n    this._id = id;\n  }\n\n  /**\n   * @internal\n   *\n   * Indicates that this object represents an ArangoDB transaction.\n   */\n  get isArangoTransaction(): true {\n    return true;\n  }\n\n  /**\n   * Database this transaction belongs to.\n   */\n  get database() {\n    return this._db;\n  }\n\n  /**\n   * Unique identifier of this transaction.\n   *\n   * See {@link databases.Database#transaction}.\n   */\n  get id() {\n    return this._id;\n  }\n\n  /**\n   * Checks whether the transaction exists.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const trx = db.transaction(\"some-transaction\");\n   * const result = await trx.exists();\n   * // result indicates whether the transaction exists\n   * ```\n   */\n  async exists(): Promise<boolean> {\n    try {\n      await this.get();\n      return true;\n    } catch (err: any) {\n      if (errors.isArangoError(err) && err.errorNum === TRANSACTION_NOT_FOUND) {\n        return false;\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Retrieves general information about the transaction.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const col = db.collection(\"some-collection\");\n   * const trx = db.beginTransaction(col);\n   * await trx.step(() => col.save({ hello: \"world\" }));\n   * const info = await trx.get();\n   * // the transaction exists\n   * ```\n   */\n  get(): Promise<TransactionInfo> {\n    return this._db.request(\n      {\n        pathname: `/_api/transaction/${encodeURIComponent(this.id)}`,\n      },\n      (res) => res.parsedBody.result\n    );\n  }\n\n  /**\n   * Attempts to commit the transaction to the databases.\n   *\n   * @param options - Options for comitting the transaction.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const col = db.collection(\"some-collection\");\n   * const trx = db.beginTransaction(col);\n   * await trx.step(() => col.save({ hello: \"world\" }));\n   * const result = await trx.commit();\n   * // result indicates the updated transaction status\n   * ```\n   */\n  commit(options: TransactionCommitOptions = {}): Promise<TransactionInfo> {\n    const { allowDirtyRead = undefined } = options;\n    return this._db.request(\n      {\n        method: \"PUT\",\n        pathname: `/_api/transaction/${encodeURIComponent(this.id)}`,\n        allowDirtyRead,\n      },\n      (res) => res.parsedBody.result\n    );\n  }\n\n  /**\n   * Attempts to abort the transaction to the databases.\n   *\n   * @param options - Options for aborting the transaction.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const col = db.collection(\"some-collection\");\n   * const trx = db.beginTransaction(col);\n   * await trx.step(() => col.save({ hello: \"world\" }));\n   * const result = await trx.abort();\n   * // result indicates the updated transaction status\n   * ```\n   */\n  abort(options: TransactionAbortOptions = {}): Promise<TransactionInfo> {\n    const { allowDirtyRead = undefined } = options;\n    return this._db.request(\n      {\n        method: \"DELETE\",\n        pathname: `/_api/transaction/${encodeURIComponent(this.id)}`,\n        allowDirtyRead,\n      },\n      (res) => res.parsedBody.result\n    );\n  }\n\n  /**\n   * Executes the given function locally as a single step of the transaction.\n   *\n   * @param T - Type of the callback's returned promise.\n   * @param callback - Callback function returning a promise.\n   *\n   * **Warning**: The callback function should wrap a single call of an async\n   * arangojs method (e.g. a method on a `Collection` object of a collection\n   * that is involved in the transaction or the `db.query` method).\n   * If the callback function is async, only the first promise-returning (or\n   * async) method call will be executed as part of the transaction. See the\n   * examples below for how to avoid common mistakes when using this method.\n   *\n   * **Note**: Avoid defining the callback as an async function if possible\n   * as arangojs will throw an error if the callback did not return a promise.\n   * Async functions will return an empty promise by default, making it harder\n   * to notice if you forgot to return something from the callback.\n   *\n   * **Note**: Although almost anything can be wrapped in a callback and passed\n   * to this method, that does not guarantee ArangoDB can actually do it in a\n   * transaction. Refer to the ArangoDB documentation if you are unsure whether\n   * a given operation can be executed as part of a transaction. Generally any\n   * modification or retrieval of data is eligible but modifications of\n   * collections or databases are not.\n   *\n   * @example\n   * ```js\n   * const db = new Database();\n   * const vertices = db.collection(\"vertices\");\n   * const edges = db.collection(\"edges\");\n   * const trx = await db.beginTransaction({ write: [vertices, edges] });\n   *\n   * // The following code will be part of the transaction\n   * const left = await trx.step(() => vertices.save({ label: \"left\" }));\n   * const right = await trx.step(() => vertices.save({ label: \"right\" }));\n   *\n   * // Results from preceding actions can be used normally\n   * await trx.step(() => edges.save({\n   *   _from: left._id,\n   *   _to: right._id,\n   *   data: \"potato\"\n   * }));\n   *\n   * // Transaction must be committed for changes to take effected\n   * // Always call either trx.commit or trx.abort to end a transaction\n   * await trx.commit();\n   * ```\n   *\n   * @example\n   * ```js\n   * // BAD! If the callback is an async function it must only use await once!\n   * await trx.step(async () => {\n   *   await collection.save(data);\n   *   await collection.save(moreData); // WRONG\n   * });\n   *\n   * // BAD! Callback function must use only one arangojs call!\n   * await trx.step(() => {\n   *  return collection.save(data)\n   *    .then(() => collection.save(moreData)); // WRONG\n   * });\n   *\n   * // BETTER: Wrap every arangojs method call that should be part of the\n   * // transaction in a separate `trx.step` call\n   * await trx.step(() => collection.save(data));\n   * await trx.step(() => collection.save(moreData));\n   * ```\n   *\n   * @example\n   * ```js\n   * // BAD! If the callback is an async function it must not await before\n   * // calling an arangojs method!\n   * await trx.step(async () => {\n   *   await doSomethingElse();\n   *   return collection.save(data); // WRONG\n   * });\n   *\n   * // BAD! Any arangojs inside the callback must not happen inside a promise\n   * // method!\n   * await trx.step(() => {\n   *   return doSomethingElse()\n   *     .then(() => collection.save(data)); // WRONG\n   * });\n   *\n   * // BETTER: Perform any async logic needed outside the `trx.step` call\n   * await doSomethingElse();\n   * await trx.step(() => collection.save(data));\n   *\n   * // OKAY: You can perform async logic in the callback after the arangojs\n   * // method call as long as it does not involve additional arangojs method\n   * // calls, but this makes it easy to make mistakes later\n   * await trx.step(async () => {\n   *   await collection.save(data);\n   *   await doSomethingDifferent(); // no arangojs method calls allowed\n   * });\n   * ```\n   *\n   * @example\n   * ```js\n   * // BAD! The callback should not use any functions that themselves use any\n   * // arangojs methods!\n   * async function saveSomeData() {\n   *   await collection.save(data);\n   *   await collection.save(moreData);\n   * }\n   * await trx.step(() => saveSomeData()); // WRONG\n   *\n   * // BETTER: Pass the transaction to functions that need to call arangojs\n   * // methods inside a transaction\n   * async function saveSomeData(trx) {\n   *   await trx.step(() => collection.save(data));\n   *   await trx.step(() => collection.save(moreData));\n   * }\n   * await saveSomeData(); // no `trx.step` call needed\n   * ```\n   *\n   * @example\n   * ```js\n   * // BAD! You must wait for the promise to resolve (or await on the\n   * // `trx.step` call) before calling `trx.step` again!\n   * trx.step(() => collection.save(data)); // WRONG\n   * await trx.step(() => collection.save(moreData));\n   *\n   * // BAD! The trx.step callback can not make multiple calls to async arangojs\n   * // methods, not even using Promise.all!\n   * await trx.step(() => Promise.all([ // WRONG\n   *   collection.save(data),\n   *   collection.save(moreData),\n   * ]));\n   *\n   * // BAD! Multiple `trx.step` calls can not run in parallel!\n   * await Promise.all([ // WRONG\n   *   trx.step(() => collection.save(data)),\n   *   trx.step(() => collection.save(moreData)),\n   * ]));\n   *\n   * // BETTER: Always call `trx.step` sequentially, one after the other\n   * await trx.step(() => collection.save(data));\n   * await trx.step(() => collection.save(moreData));\n   *\n   * // OKAY: The then callback can be used if async/await is not available\n   * trx.step(() => collection.save(data))\n   *   .then(() => trx.step(() => collection.save(moreData)));\n   * ```\n   *\n   * @example\n   * ```js\n   * // BAD! The callback will return an empty promise that resolves before\n   * // the inner arangojs method call has even talked to ArangoDB!\n   * await trx.step(async () => {\n   *   collection.save(data); // WRONG\n   * });\n   *\n   * // BETTER: Use an arrow function so you don't forget to return\n   * await trx.step(() => collection.save(data));\n   *\n   * // OKAY: Remember to always return when using a function body\n   * await trx.step(() => {\n   *   return collection.save(data); // easy to forget!\n   * });\n   *\n   * // OKAY: You do not have to use arrow functions but it helps\n   * await trx.step(function () {\n   *   return collection.save(data);\n   * });\n   * ```\n   *\n   * @example\n   * ```js\n   * // BAD! You can not pass promises instead of a callback!\n   * await trx.step(collection.save(data)); // WRONG\n   *\n   * // BETTER: Wrap the code in a function and pass the function instead\n   * await trx.step(() => collection.save(data));\n   * ```\n   *\n   * @example\n   * ```js\n   * // WORSE: Calls to non-async arangojs methods don't need to be performed\n   * // as part of a transaction\n   * const collection = await trx.step(() => db.collection(\"my-documents\"));\n   *\n   * // BETTER: If an arangojs method is not async and doesn't return promises,\n   * // call it without `trx.step`\n   * const collection = db.collection(\"my-documents\");\n   * ```\n   */\n  step<T>(callback: () => Promise<T>): Promise<T> {\n    const conn = (this._db as any)._connection as connection.Connection;\n    conn.setTransactionId(this.id);\n    try {\n      const promise = callback();\n      if (!promise) {\n        throw new Error(\n          \"Transaction callback was not an async function or did not return a promise!\"\n        );\n      }\n      return Promise.resolve(promise);\n    } finally {\n      conn.clearTransactionId();\n    }\n  }\n}\n//#endregion\n"]}