{"version":3,"file":"x3-linkedlist.js","sourceRoot":"","sources":["../../../src/lib/x3-linkedlist.ts"],"names":[],"mappings":"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","sourcesContent":["/**!\n * x3-linkedlist\n *\n * MIT License\n *\n * Copyright (c) 2019 Benno Dreißig\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\nexport class LinkedListItem<T> {\n  /**\n   * Item behind this item\n   * ```\n   * A -> ThisItem -> C\n   *                  ^\n   * ```\n   */\n  public behind: LinkedListItem<T> | undefined;\n\n  /**\n   * Item before this item\n   * ```\n   * A -> ThisItem -> C\n   * ^\n   * ```\n   */\n  public before: LinkedListItem<T> | undefined;\n\n  constructor(\n    /**\n     * Value of this item\n     */\n    public value: T,\n    /**\n     *Function to run on unlink() call. Usually used by LinkedList to fix first and last pointers and reduce length.\n     */\n    protected unlinkCleanup?: (item: LinkedListItem<T>) => void,\n  ) {}\n\n  /**\n   * This will link given LinkListItem behind this item.\n   * If there's already a LinkedListItem linked behind, it will be relinked accordingly\n   */\n  public insertBehind(\n    /** LinkListItem to be inserted behind this one */\n    item: LinkedListItem<T>,\n  ): void {\n    item.insertBefore(this);\n\n    if (this.behind) {\n      let itemChainEnd = item;\n      while (itemChainEnd.behind) itemChainEnd = itemChainEnd.behind;\n\n      this.behind.insertBefore(itemChainEnd);\n      itemChainEnd.insertBehind(this.behind);\n    }\n    this.behind = item;\n  }\n\n  /**\n   * Unlinks this LinkedListItem and calls unlinkCleanup\n   * @see LinkedListItem#unlinkCleanup\n   */\n  public unlink(\n    /** If true, additionally removes the reference to the item before and behind */\n    unchain = false,\n  ): void {\n    if (this.before) this.before.behind = this.behind;\n\n    if (this.behind) {\n      this.behind.before = this.before;\n    }\n    if (this.unlinkCleanup) {\n      this.unlinkCleanup(this);\n    }\n    this.unlinkCleanup = undefined;\n\n    if (unchain) {\n      this.before = this.behind = undefined;\n    }\n  }\n\n  /**\n   * Item given will be inserted before this item.\n   * unlinkCleanup will be copied if neccessary.\n   * This function is protected, because LinkedListItem's can only be attached behind.\n   * @see insertBehind\n   */\n  protected insertBefore(\n    /** LinkListItem to be inserted before this one */\n    before: LinkedListItem<T>,\n  ): void {\n    this.before = before;\n    if (!this.unlinkCleanup) {\n      this.unlinkCleanup = before.unlinkCleanup;\n    }\n  }\n}\n\n/**\n * Implements a linked list structure\n * @typeparam T - Type of values within this LinkedList\n */\nexport class LinkedList<T> {\n  /**\n   * First item in list\n   */\n  public first: LinkedListItem<T> | undefined;\n\n  /**\n   * Last item in list\n   */\n  public last: LinkedListItem<T> | undefined;\n\n  /**\n   * Current length of this LinkedList.\n   * Note that this does not work anymore if you for some reason add your own LinkedListItems to LinkedList by hand\n   */\n  public length = 0;\n\n  constructor(\n    /** Values to be added initially into list */\n    values?: Iterable<T> | LinkedList<T>,\n  ) {\n    if (values) {\n      if (values instanceof LinkedList) values = values.values();\n\n      for (const value of values) {\n        this.push(value);\n      }\n    }\n  }\n\n  /**\n   * Clears this LinkedList.\n   * The default complexity is O(1), because it only removes links to the first and last item and resets the length.\n   * Note that if any LinkedListItem is still referenced outside the LinkedList, their before and behind fields might\n   * still reference the chain, not freeing space.\n   *\n   * You can set the unchain parameter to true, so every item in the linked list will be unchained,\n   * meaning all references to before and behind items will be removed.\n   * This increases complexity to O(n), but removes accidental outside references to the full chain.\n   */\n  public clear(\n    /** If `true`, remove link info from every item. Changes complexity to O(n)! */\n    unchain = false,\n  ): void {\n    if (unchain) {\n      while (this.first) {\n        this.first.unlink(true);\n      }\n    }\n\n    this.first = this.last = undefined;\n    this.length = 0;\n  }\n\n  /**\n   * As Array#every() given callback is called for every element until one call returns falsy or all elements had been processed\n   * @returns `false` if there was a falsy response from the callback, `true` if all elements have been processed \"falselesly\"\n   * @see Array#every\n   */\n  public every<C>(\n    /** Runs for every item in the LinkedList */\n    callback: (value: T, item: LinkedListItem<T>, list: this) => boolean,\n    /** If given, callback function will be bound to thisArg */\n    thisArg?: C,\n  ): boolean {\n    if (thisArg) {\n      callback = callback.bind(thisArg);\n    }\n\n    for (const item of this.keys()) {\n      if (!callback(item.value, item, this)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Filters values into a new LinkedList\n   * @see Array#filter\n   */\n  public filter<C>(\n    /** decides wether given element should be part of new LinkedList */\n    callback: (value: T, item: LinkedListItem<T>, list: this) => boolean,\n    /** If given, callback function will be bound to thisArg */\n    thisArg?: C,\n  ): LinkedList<T> {\n    if (thisArg) {\n      callback = callback.bind(thisArg);\n    }\n\n    const newList: LinkedList<T> = new LinkedList();\n    for (const [item, value] of this) {\n      if (callback(value, item, this)) {\n        newList.push(value);\n      }\n    }\n    return newList;\n  }\n\n  /**\n   * Returns value for which given callback returns truthy\n   * @see Array#find\n   */\n  public find<C>(\n    /** runs for every value in LinkedList. If it returns truthy, current value is returned. */\n    callback: (value: T, item: LinkedListItem<T>, list: this) => boolean,\n    /** If given, callback function will be bound to thisArg */\n    thisArg?: C,\n  ): T | undefined {\n    if (thisArg) {\n      callback = callback.bind(thisArg);\n    }\n\n    for (const [item, value] of this) {\n      if (callback(value, item, this)) {\n        return value;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Returns the LinkedListItem for which given callback returns truthy\n   * @see Array#findIndex\n   */\n  public findItem<C>(\n    /** runs for every LinkedListItem in LinkedList. If it returns truthy, current LinkedListItem is returned. */\n    callback: (value: T, item: LinkedListItem<T>, list: this) => boolean,\n    /** If given, callback function will be bound to thisArg */\n    thisArg?: C,\n  ): LinkedListItem<T> | undefined {\n    if (thisArg) {\n      callback = callback.bind(thisArg);\n    }\n\n    for (const [item, value] of this) {\n      if (callback(value, item, this)) {\n        return item;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Iterates this LinkedList's items and values\n   * @see Array#forEach\n   */\n  public forEach<C>(\n    /** Gets every value in LinkedList once with corresponding LinkedListItem and LinkedList */\n    callback: (value: T, item: LinkedListItem<T>, list: this) => void,\n    /** If given, callback function will be bound to thisArg */\n    thisArg?: C,\n  ): void {\n    if (thisArg) {\n      callback = callback.bind(thisArg);\n    }\n    for (const [item, value] of this) {\n      callback(value, item, this);\n    }\n  }\n\n  /**\n   * Checks if value can be found within LinkedList, starting from fromIndex, if given.\n   * @returns true if value could be found in LinkedList (respecting fromIndex), false otherwhise\n   * @see Array#includes\n   */\n  public includes(\n    /** value to be found in this */\n    value: T,\n    /** Starting index. Supports negative values for which `this.size - 1 + fromIndex` will be used as starting point. */\n    fromIndex = 0,\n  ): boolean {\n    let current = this.getItemByIndex(fromIndex);\n    while (current) {\n      if (current.value === value) {\n        return true;\n      }\n      current = current.behind;\n    }\n    return false;\n  }\n\n  /**\n   * Searches forward for given value and returns the first corresponding LinkedListItem found\n   * @see Array#indexOf\n   */\n  public itemOf(\n    /** Value to be found */\n    searchedValue: T,\n    /** Index to start from */\n    fromIndex = 0,\n  ): LinkedListItem<T> | undefined {\n    let current = this.getItemByIndex(fromIndex);\n    while (current) {\n      if (current.value === searchedValue) {\n        return current;\n      }\n      current = current.behind;\n    }\n    return;\n  }\n\n  /**\n   * Searches backwards for given value and returns the first corresponding LinkedListItem found\n   * @see Array#indexOf\n   */\n  public lastItemOf(\n    /** Value to be found */\n    searchedValue: T,\n    /** Index to start from */\n    fromIndex = -1,\n  ): LinkedListItem<T> | undefined {\n    let current = this.getItemByIndex(fromIndex);\n    while (current) {\n      if (current.value === searchedValue) {\n        return current;\n      }\n      current = current.before;\n    }\n    return;\n  }\n\n  /**\n   * Creates a new LinkedList with each of its itesm representing the output of the callback with each item in current LinkedList.\n   * @see Array#map\n   */\n  public map<V, C>(\n    /** Gets value, LinkedListeItem and LinkedList. The response will be used as value in the new LinkedList */\n    callback: (value: T, item: LinkedListItem<T>, list: this) => V,\n    /** If given, callback function will be bound to thisArg */\n    thisArg?: C,\n  ): LinkedList<V> {\n    if (thisArg) {\n      callback = callback.bind(thisArg);\n    }\n    const newList = new LinkedList<V>();\n    for (const [item, value] of this) {\n      newList.push(callback(value, item, this));\n    }\n    return newList;\n  }\n\n  /**\n   * From Array#reduce on MDN: The reduce() method executes a reducer function (that you provide) on each element of the LinkedList,\n   * resulting in a single output value.\n   * @see Array#reduce\n   */\n  public reduce<V>(\n    /**\n     * Gets first value, current value (starting with the second value), LinkedListeItem and LinkedList.\n     * Note that currentItem will be the second item on first call.\n     * The response will be used as the next accumulator.\n     */\n    callback: (\n      accumulator: T,\n      currentValue: T,\n      currentItem: LinkedListItem<T>,\n      list: this,\n    ) => V,\n  ): V;\n  public reduce<V>(\n    /**\n     * Gets initialValue as accumulator initially, LinkedListeItem and LinkedList.\n     * The response will be used as the next accumulator.\n     */\n    callback: (\n      accumulator: V,\n      currentValue: T,\n      currentItem: LinkedListItem<T>,\n      list: this,\n    ) => V,\n    /** Value for the first call of callback */\n    initialValue: V,\n  ): V;\n  public reduce<V>(\n    callback: (\n      accumulator: V | T,\n      currentValue: T,\n      currentItem: LinkedListItem<T>,\n      list: this,\n    ) => V,\n    initialValue?: V | T,\n  ): V | T {\n    let current = this.first;\n    if (!current) {\n      if (!initialValue) {\n        throw new TypeError(\n          \"Empty accumulator on empty LinkedList is not allowed.\",\n        );\n      }\n      return initialValue;\n    }\n\n    if (initialValue === undefined) {\n      initialValue = current.value;\n      if (!current.behind) {\n        return initialValue;\n      }\n      current = current.behind;\n    }\n\n    do {\n      initialValue = callback(initialValue, current.value, current, this);\n      current = current.behind;\n    } while (current);\n    return initialValue;\n  }\n\n  /**\n   * From Array#reduceRight on MDN: The reduceRight() method applies a function against an accumulator and each value of the LinkedList (from last-to-first)\n   * to reduce it to a single value.\n   * @see Array#reduceRight\n   * @see LinkedList#reduce\n   */\n  public reduceRight<V>(\n    /**\n     * Gets the last value, current value (starting with the second-to-last value), LinkedListeItem and LinkedList.\n     * Note that currentItem will be the second-to-last item on the first call.\n     * The response will be used as the next accumulator.\n     */\n    callback: (\n      accumulator: T,\n      currentValue: T,\n      currentItem: LinkedListItem<T>,\n      list: this,\n    ) => V,\n  ): V;\n  public reduceRight<V>(\n    /**\n     * Gets initialValue as accumulator initially, LinkedListeItem and LinkedList.\n     * The response will be used as the next accumulator.\n     */\n    callback: (\n      accumulator: V,\n      currentValue: T,\n      currentItem: LinkedListItem<T>,\n      list: this,\n    ) => V,\n    /** Value for the first call of callback */\n    initialValue: V,\n  ): V;\n  public reduceRight<V>(\n    callback: (\n      accumulator: V | T,\n      currentValue: T,\n      currentItem: LinkedListItem<T>,\n      list: this,\n    ) => V,\n    initialValue?: V | T,\n  ): V | T {\n    let current = this.last;\n    if (!current) {\n      if (!initialValue) {\n        throw new TypeError(\n          \"Empty accumulator on empty LinkedList is not allowed.\",\n        );\n      }\n      return initialValue;\n    }\n    if (initialValue === undefined) {\n      initialValue = current.value;\n      if (!current.before) {\n        return initialValue;\n      }\n      current = current.before;\n    }\n\n    do {\n      initialValue = callback(initialValue, current.value, current, this);\n      current = current.before;\n    } while (current);\n    return initialValue;\n  }\n\n  /**\n   * Runs callback for every entry and returns true immediately if call of callback returns truthy.\n   * @returns `true` once a callback call returns truthy, `false` if none returned truthy.\n   */\n  public some<C>(\n    /** called for every element. If response is truthy, this currentvalue will be returned by `.some()`. */\n    callback: (currentValue: T, item: LinkedListItem<T>, list: this) => boolean,\n    /** If given, callback function will be bound to thisArg */\n    thisArg?: C,\n  ): boolean {\n    if (thisArg) {\n      callback = callback.bind(thisArg);\n    }\n    for (const [item, value] of this) {\n      if (callback(value, item, this)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Joins values within this by given separator. Uses Array#join directly.\n   * @see Array#join\n   */\n  public join(\n    /** separator between items in the resulting string */\n    separator?: string,\n  ): string {\n    return [...this.values()].join(separator);\n  }\n\n  /**\n   * Concats given values and returns a new LinkedList with all given values.\n   * If LinkedList's are given, they will be spread.\n   * @see Array#concat\n   */\n  public concat<V>(\n    /** Other values or lists to be concat'ed together */\n    ...others: Array<V | LinkedList<V>>\n  ): LinkedList<V | T> {\n    const newList = new LinkedList<V | T>(this as LinkedList<V | T>);\n    for (const other of others) {\n      if (other instanceof LinkedList) {\n        newList.push(...other.values());\n      } else {\n        newList.push(other);\n      }\n    }\n    return newList;\n  }\n\n  /**\n   * Removes the last LinkedListItem and returns its inner value\n   */\n  public pop(): T | undefined {\n    if (!this.last) {\n      return;\n    }\n    const item = this.last;\n    item.unlink();\n    return item.value;\n  }\n\n  /**\n   * Adds given values on the end of this LinkedList\n   */\n  public push(\n    /** Values to be added */\n    ...values: T[]\n  ): number {\n    for (const value of values) {\n      const item = new LinkedListItem(value, this.unlinkCleanup);\n      if (!this.first || !this.last) {\n        this.first = this.last = item;\n      } else {\n        this.last.insertBehind(item);\n        this.last = item;\n      }\n      this.length++;\n    }\n    return this.length;\n  }\n\n  /**\n   * Adds given values to the beginning of this LinkedList\n   */\n  public unshift(\n    /** Values to be added */\n    ...values: T[]\n  ): number {\n    for (const value of values) {\n      const item = new LinkedListItem(value, this.unlinkCleanup);\n      if (!this.last || !this.first) {\n        this.first = this.last = item;\n      } else {\n        item.insertBehind(this.first);\n        this.first = item;\n      }\n      this.length++;\n    }\n    return this.length;\n  }\n\n  /**\n   * Removes first occurrence of value found.\n   */\n  public remove(\n    /** value to remove once */\n    value: T,\n  ): boolean {\n    for (const item of this.keys()) {\n      if (item.value === value) {\n        item.unlink();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Removes every occurrance of value within this.\n   */\n  public removeAllOccurrences(\n    /** value to remove completely */\n    value: T,\n  ): boolean {\n    let foundSomethingToDelete = false;\n\n    for (const item of this.keys()) {\n      if (item.value === value) {\n        item.unlink();\n        foundSomethingToDelete = true;\n      }\n    }\n\n    return foundSomethingToDelete;\n  }\n\n  /**\n   * Returns and removes first element from LinkedList\n   */\n  public shift(): T | undefined {\n    if (!this.first) {\n      return;\n    }\n    const item = this.first;\n    item.unlink();\n    return item.value;\n  }\n\n  /**\n   * Returns LinkedListItem and value for every entry of this LinkedList\n   */\n  public *[Symbol.iterator](): IterableIterator<[LinkedListItem<T>, T]> {\n    let current = this.first;\n    if (!current) {\n      return;\n    }\n    do {\n      yield [current, current.value];\n      current = current.behind;\n    } while (current);\n  }\n\n  /**\n   * Returns LinkedListItem and value for every entry of this LinkedList\n   * @see LinkedList#Symbol.iterator\n   */\n  public entries(): IterableIterator<[LinkedListItem<T>, T]> {\n    return this[Symbol.iterator]();\n  }\n\n  /**\n   * Iterates the LinkedListItem's of this LinkedList\n   */\n  public *keys(): IterableIterator<LinkedListItem<T>> {\n    let current = this.first;\n    if (!current) {\n      return;\n    }\n    do {\n      yield current;\n      current = current.behind;\n    } while (current);\n  }\n\n  /**\n   * Returns a value for every entry of this LinkedList\n   */\n  public *values(): IterableIterator<T> {\n    let current = this.first;\n    if (!current) {\n      return;\n    }\n\n    do {\n      yield current.value;\n      current = current.behind;\n    } while (current);\n  }\n\n  /**\n   * Returns the item by given index.\n   * Supports negative values and will return the item at `LinkedList.size - 1 + index` in that case.\n   */\n  private getItemByIndex(\n    /** Index of item to get from list */\n    index: number,\n  ): LinkedListItem<T> | undefined {\n    if (index === undefined) {\n      throw new Error(\"index must be a number!\");\n    }\n    if (!this.first) {\n      return;\n    }\n    let current: LinkedListItem<T> | undefined;\n    if (index > 0) {\n      current = this.first;\n      while (current && index--) {\n        current = current.behind;\n      }\n    } else if (index < 0) {\n      current = this.last;\n      while (current && ++index) {\n        current = current.before;\n      }\n    } else {\n      return this.first;\n    }\n\n    return current;\n  }\n\n  /**\n   * Given to own LinkedListItem's for following jobs regarding an unlink:\n   * - If item is first item, set the next item as first item\n   * - If item is last item, set the previous item as last item\n   * - Decrease length\n   */\n  private unlinkCleanup = (\n    /** Item that has been unlinked */\n    item: LinkedListItem<T>,\n  ): void => {\n    if (this.first === item) {\n      this.first = this.first.behind;\n    }\n    if (this.last === item) {\n      this.last = this.last.before;\n    }\n    this.length--;\n  };\n}\n"]}